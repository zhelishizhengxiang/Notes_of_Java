线程活跃性：线程内的代码是有限的，但是线程的代码一直执行不完

线程活跃性问题包括死锁、活锁和饥饿三种情况
## 1.死锁
![](assets/10线程的活跃性/file-20250911210523310.png)![](assets/10线程的活跃性/file-20250911210544403.png)


### .12定位死锁
![](assets/10线程的活跃性/file-20250911210909611.png)
![](assets/10线程的活跃性/file-20250911210956943.png)
![](assets/10线程的活跃性/file-20250911211019034.png)

### 1.3哲学家就餐问题
![](assets/10线程的活跃性/file-20250911211219171.png)![](assets/10线程的活跃性/file-20250911211438847.png)
![](assets/10线程的活跃性/file-20250911211453805.png)![](assets/10线程的活跃性/file-20250911211515568.png)
![](assets/10线程的活跃性/file-20250911211554459.png)
![](assets/10线程的活跃性/file-20250911211651511.png)![](assets/10线程的活跃性/file-20250911211716145.png)


## 2.活锁
![](assets/10线程的活跃性/file-20250911212047601.png)

## 3.饥饿问题
饥饿定义为，一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束，饥饿的情况不易演示，讲读写锁时会涉及饥饿问题

![](assets/10线程的活跃性/file-20250911212304831.png)

死锁的问题：顺序加锁
![](assets/10线程的活跃性/file-20250911212338942.png)

但是顺序加锁容易产生饥饿问题。如果线程1一直能竞争到线程对象a的锁