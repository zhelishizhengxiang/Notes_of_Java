垃圾回收器可以分为以下几类：
1. 串行
2. 吞吐量优先
3. 响应时间优先

![](assets/05垃圾回收器/file-20250422215946795.png)
 ![](assets/05垃圾回收器/file-20250422220802428.png)
## 1.串行垃圾回收器

![](assets/05垃圾回收器/file-20250422221005714.png)
* **新生代老年代使用不同的垃圾回收器，Serial是工作在新生代的回收器（采用复制算法），SerialOld是工作在老年代的回收器（采用标记整理算法）**

![](assets/05垃圾回收器/file-20250422221230525.png)![](assets/05垃圾回收器/file-20250422221327678.png)


## 2.吞吐量优先垃圾回收器
**JDK1.8默认使用的就是ParallelGC这个垃圾回收器，Parallel是并行的**

![](assets/05垃圾回收器/file-20250422221858360.png)
* 到达安全点后，垃圾回收器会开多个线程来进行垃圾回收，尽快把垃圾回收。具体开启的线程个数与CPU核数相关
* **说明：-XX:ParallelGCThreads=n是控制垃圾回收时的垃圾回收线程的数量**

![](assets/05垃圾回收器/file-20250422222114714.png)
![](assets/05垃圾回收器/file-20250422222132741.png)
* -XX:+UseAdaptiveSizePolicy是采用自适应的大小调节策略（调整新生代的大小以及Eden区和幸存去的比例）    
	![](assets/05垃圾回收器/file-20250422222226708.png)

* 下面那设置的两个目标是相悖的，需要根据实际情况取一个折中的值

	![](assets/05垃圾回收器/file-20250422222455790.png)  


## 3.响应时间优先的垃圾回收器
![](assets/05垃圾回收器/file-20250422223029932.png)
* -XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld：**代表concurrent的标清除算法的垃圾回收器，即CMS回收器，是一款工作在老年代的回收器。UseParNewGC是工作在新生代的基于复制算法的垃圾回收器**
* **CMS回收器会有并发失败的情况发生，在这种情况下会采取补救措施：让老年代回收器CMS退化成SerialOld(基于标记整理算法的单线程回收器)**    
	![](assets/05垃圾回收器/file-20250422223122358.png)
* CMS回收器的工作流程如下图所示：  
	![](assets/05垃圾回收器/file-20250422223400226.png)

* -XX:ParallelGCThreads=n :代表并行的垃圾回收线程数
* -XX:ConcGCThreads=threads：代表并发的垃圾回收线程数
* -XX:CMSInitiatingOccupancyFraction=percent：代表执行CMS垃圾回收的内存占比，即只要老年代的内存占用到达这个比例的时候，就执行一次垃圾回收。这是为了预留空间来存储那些浮动垃圾
* -XX:+CMSScavengeBeforeRemark：其作用是在 CMS 的 **Remark 阶段**之前，先触发一次 **Minor GC**（新生代垃圾回收）。具体原理如下图所示  
	![](assets/05垃圾回收器/file-20250822120228328.png)