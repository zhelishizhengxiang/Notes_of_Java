## 1.方法区的定义和组成
![](assets/05方法区/file-20250419165229664.png)

![](assets/05方法区/file-20250418211232872.png)
* **在jdk1.7及以前，方法区的实现是永久代，永久代是JVM堆的一个逻辑分区。属于堆内存的一部分。**
* **class是类的信息，ClassLoader是类加载器，运行时常量池包括字符串表和常量的存储**

![](assets/05方法区/file-20250418211406374.png)
* **jdk1.8及以后，方法区的逻辑实现是元空间，物理上存储在操作系统的本地内存**
* **在1.6中方法区是在堆中，在1.8之后是在本地内存（操作系统内存）**
* **字符串表在1.7及以前是存储在方法区中，也就是堆中；在1.8及以后不在存储在方法去的实现当中，而是直接存储在堆中**

## 2.方法区内存溢出
![](assets/05方法区/file-20250807210247352.png)

1.8之后的方法区内存溢出实例：

![](assets/05方法区/file-20250807210711496.png)

1.8之前的方法区内存溢出实例：

![](assets/05方法区/file-20250418212508364.png)


## 3.（运行时）常量池
![](assets/05方法区/file-20250418213218845.png)
* 一个类的二进制字节码内容如上图所示
* 类的方法定义中包含了虚拟机的指令（这些指令也就是方法内容，只不过转变成了虚拟机指令）

类的基本信息：  
![](assets/05方法区/file-20250807212018413.png)

常量池：      
![](assets/05方法区/file-20250418213306310.png)

类的方法定义（包含了虚拟机的指令）：   
![](assets/05方法区/file-20250418215900292.png)

常量池和运行时常量池的区别如下图所示  
![](assets/05方法区/file-20250807212315812.png)
## 4.StringTable串池

#### 4.1 串池的定义和使用
![](assets/05方法区/file-20250807212804229.png)

例子1：

![](assets/05方法区/file-20250418215630922.png)
* **等到具体执行到引用它的那一行代码时，a，b这些符号才会变为java字符串对象**
* **变为java对象的过程也就是放入串池，先在串池中找串池中没有，就把他放入串池；如果串池中已经有了，那么就使用串池中的对象**
* **StringTable是HashTable结构，也就是key-value结构，不能扩容**
* 对于上面两条的具体例子如下图所示

	![](assets/05方法区/file-20250418221442958.png)
	![](assets/05方法区/file-20250418221457418.png)
	* 可以发现后面又打印10个之后，字符串个数还是2285个

例子2：字符串变量拼接

![](assets/05方法区/file-20250807213641758.png)
![](assets/05方法区/file-20250418220648014.png)

例子3：编译期优化：当拼接的**全部是字符串字面量**（即代码中直接写死的 `"字符串"`，不含变量）时，编译器会在编译阶段（而非运行时）直接合并这些字面量。等价于直接写 `String s1 = "hellojava"`

![](assets/05方法区/file-20250418220805990.png)
* ldc  \#4就是去常量池中找编号为4的符号
![](assets/05方法区/file-20250418221157597.png)


#### 4.2 StringTable特性总结（难点和重点）
![](assets/05方法区/file-20250418234739354.png)

##### 字符串池入池规则
1. ​**​字面量自动入池​**​：直接通过字面量（如 `"ab"`）声明字符串时，JVM 会检查常量池是否存在该字符串：
    - 若存在，直接引用池中对象；
    - 若不存在，创建新对象并放入池中。
2. **因拼接生成的字符串不会自动入池**。**`new String("a") + new String("b")` 生成的 "ab" 不会触发自动入池​**​。  只有通过字面量（如 `"ab"`）或显式调用 `intern()` 时，才会操作常量池
##### intern方法
JavaSE的intern方法的讲解有误，那么最精确的如下所示：

![](assets/05方法区/file-20250418233810454.png)
* **所以intern方法具体事项是根据jdk而有所区别的
* **并且注意图片中的常量池指的是StringTable，而不是常量池，常量池在8之后时在元空间中**
![](assets/05方法区/file-20250418232850856.png)
* **注意如果StringTable串池中不存在与str内容相同的字符串，jdk1.8之后是将str的引用赋值到常量池中（也就是常量池中的引用指向的是堆中的对象），jdk1.6将字符串内容在池中生成一个"ab"，然后让str中存储字符串内容的字符数组来指向池子中的内容**


###### 1.8 intern例题
例1

![](assets/05方法区/file-20250418233534295.png)
![](assets/05方法区/file-20250418233614048.png)
* **`s.intern()` 前​**​：常量池无 `"ab"`，`s` 是堆中的独立对象
* 调用intern以后，池中 `"ab"` 的引用​**​指向堆中的 `s` 对象​**​

例2

![](assets/05方法区/file-20250418234240573.png)
![](assets/05方法区/file-20250418234348114.png)
######  1.6integer例题
此时图中的代码并不是两个true，而是一个true一个false

![](assets/05方法区/file-20250418235020068.png)


#### 4.3.StringTable位置
![](assets/05方法区/file-20250421142232605.png)
* 永久代是逻辑位置，本质也是在堆中
#### 3.StringTable的垃圾回收  
![](assets/05方法区/file-20250421143126592.png)
* **StringTable也会发生垃圾回收，不是只有堆中的对象会发生垃圾回收。因为StringTable物理上也是存在在堆中的**

#### StringTable的性能调优

![](assets/05方法区/file-20250421143919600.png)
* StringTable的桶个数默认是60013个