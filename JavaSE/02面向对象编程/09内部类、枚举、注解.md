首先需要知道：类的五大成员：属性、方法、构造器、代码块和内部类
## 1）内部类
内部类：一个类的内部又完整的嵌套了另一个类结构，被嵌套的类称为内部类，其语法格式如下图所示：

![](assets/09内部类、枚举、注解/file-20250213152458225.png)

内部类最大的特点：**可直接访问外部类私有属性，并且可以体现类与类之间的包含关系**

内部类的分类：  
1. 根据定义在外部类的局部位置上（比如方法内）
	* 局部内部类（有类名）
	* 匿名内部类（没有类名，重点）
2. 根据定义在外部类的成员位置上：
	* 成员内部类（没有static修饰）
	* 静态内部类（有static修饰）

接下来进行一一讲解

### 1.局部内部类
局部内部类：定义在外部类的局部位置，比如方法中或代码块中，并且有类名

![](assets/09内部类、枚举、注解/file-20250213173531497.png)

要点（以上图代码为例子）：  
1. **可以直接访问外部类的所有成员**，**包含私有的**
2. 不能添加访问修饰符，因为**其地位就相当于一个局部变量，局部变量不能有修饰符**。但是可以使用final修饰，因为局部变量也可以使用final，此时就表示该内部类不能被继承
3. 作用域：仅仅在定义它的方法或代码块内
4. 局部内部类访问外部类的成员的访问方式：直接访问
5. 外部类访问局部内部类的成员的访问方式：外部类在方法中创建对象，再访问（并且要在作用域内）
6. **外部其他类不能访问局部内部类**（因为局部内部类地位相当于一个局部变量）
7. 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以：外部类名.this.成员 的语法格式去访问
8. 对于外部类名.this.成员的解读：本质上就是外部类的对象，即那个对象调用了m1，外部类名.this.就是哪个对象


### 2.匿名内部类（最重要）
![](assets/09内部类、枚举、注解/file-20250213173950121.png)
基于接口的匿名内部类：  
![](assets/09内部类、枚举、注解/file-20250213175053459.png) ![](assets/09内部类、枚举、注解/file-20250213175338313.png)
* 图中的内部类是只能使用一次，但是创还能得对象实例可以一直使用，只要tiger没有丢失可以一直调用cry方法

基于类的匿名内部类（会用到参数列表）：  
![](assets/09内部类、枚举、注解/file-20250213180443723.png)
![](assets/09内部类、枚举、注解/file-20250213180501574.png)

使用细节：

![](assets/09内部类、枚举、注解/file-20250213180603464.png)
![](assets/09内部类、枚举、注解/file-20250213181430084.png)
![](assets/09内部类、枚举、注解/file-20250213181638498.png)


匿名内部类的经典使用场景：（上述写法在开发中很常见）

![](assets/09内部类、枚举、注解/file-20250213182346892.png)
![](assets/09内部类、枚举、注解/file-20250213182306111.png)
![](assets/09内部类、枚举、注解/file-20250213182521654.png)

### 3.成员内部类
![](assets/09内部类、枚举、注解/file-20250213183327716.png)
![](assets/09内部类、枚举、注解/file-20250213183742735.png)
![](assets/09内部类、枚举、注解/file-20250213183936193.png)

![](assets/09内部类、枚举、注解/file-20250213183812018.png)
![](assets/09内部类、枚举、注解/file-20250213184523992.png)

![](assets/09内部类、枚举、注解/file-20250213184609755.png)
![](assets/09内部类、枚举、注解/file-20250213184637120.png)

1. 非静态内部类对象必须依存在一个外部类对象里。  因此，如果有一个非静态内部类对象那么一定存在对应的外部类对象。  
2. 非静态内部类对象单独属于外部类的某个对象。

所以有以下两种外部类访问成员内部类的方式：
![](assets/09内部类、枚举、注解/file-20250213185236119.png)
![](assets/09内部类、枚举、注解/file-20250213185350825.png)![](assets/09内部类、枚举、注解/file-20250213185413507.png)
![](assets/09内部类、枚举、注解/file-20250213185553346.png)


### 4.静态内部类
![](assets/09内部类、枚举、注解/file-20250213185812064.png)
* 静态内部类看做外部类的一个静态成员
![](assets/09内部类、枚举、注解/file-20250213190054901.png)
![](assets/09内部类、枚举、注解/file-20250213190225185.png)
![](assets/09内部类、枚举、注解/file-20250213190249259.png)![](assets/09内部类、枚举、注解/file-20250213190332720.png)
![](assets/09内部类、枚举、注解/file-20250213190620246.png)
![](assets/09内部类、枚举、注解/file-20250213190557257.png)
![](assets/09内部类、枚举、注解/file-20250213190753381.png)
* 因为静态内部类中只能访问静态成员

内部类小结：

![](assets/09内部类、枚举、注解/file-20250213191041290.png)

## 2）枚举类
枚举是一组常量的集合，也可以理解为一种特殊的类，里面只包含一组有限的特定的对象

枚举的两种实现方式：
1. 自定义类实现枚举
2. 使用enum关键字实现枚举

### 1.自定义类实现枚举类
1. 不需要提供setter，**因为枚举对象通常为只读**
2. **对枚举对象/属性使用final+static共同修饰**，实现只读和底层优化
3. **枚举对象名通常使用全部大写**，也就是常量的命名规范
4. **枚举对象根据需要，也可以有多个属性**，并且枚举对象他是已经定义的对象！
5. 如果有构造器，那么给构造器私有化，这样就不会new出新对象

![](assets/09内部类、枚举、注解/file-20250213195635980.png)

### 2.使用enum关键字实现枚举类
步骤如下（是从上面自定义类改动下来的步骤，如果没提，那么其他地方保持相同）：  
1. 使用enum关键字替代class  
2. public final static Season2 SPRING=new Season2("春天","温暖");直接使用 SPRING("春天","温暖");替代  
3. **SPRING("春天","温暖");解读：常量名(实参列表)，上一行两句话一样，只是简化了**
4. 如果有多个常量(对象)，使用逗号间隔即可  
5. 如果使用enum来实现枚举，那么要将定义的常量对象，写在最前面

![](assets/09内部类、枚举、注解/file-20250213201537497.png)

使用时的注意事项：
1. **当我们使用enum关键字开发一个枚举类时，此类会被编译为final类，并且隐式继承Enum类**
	![](assets/09内部类、枚举、注解/file-20250213202104771.png)
2. 传统的public final static Season2 SPRING=new Season2("春天","温暖");直接使用 SPRING("春天","温暖")，这里必须知道，它调用的哪个构造器
3. **如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略**

	![](assets/09内部类、枚举、注解/file-20250213202330462.png)
4. 当有多个枚举对象时，使用逗号间隔，并用分号结尾
5. **枚举对象必须放在枚举类的行首**

示例：  
![](assets/09内部类、枚举、注解/file-20250213202513613.png)
![](assets/09内部类、枚举、注解/file-20250213203035905.png)
* 常量对象都是静态常量，也就是上面说到的public static final，所以只有一份，所以输出true
Enum类的toString的方法如下图所示：

![](assets/09内部类、枚举、注解/file-20250213202857339.png)

Enum类的成员方法在开发中经常会用到，接下来对其进行介绍  

![](assets/09内部类、枚举、注解/file-20250213224114894.png)

![](assets/09内部类、枚举、注解/file-20250213225412072.png)![](assets/09内部类、枚举、注解/file-20250213230312133.png)

![](assets/09内部类、枚举、注解/file-20250213230458850.png)

## 3）注解
### 1.三种常用注解
![](assets/09内部类、枚举、注解/file-20250213230818934.png)
![](assets/09内部类、枚举、注解/file-20250213231008624.png)
2. @Override注解
![](assets/09内部类、枚举、注解/file-20250213231238399.png)
![](assets/09内部类、枚举、注解/file-20250213231527363.png)
![](assets/09内部类、枚举、注解/file-20250213231831734.png)
![](assets/09内部类、枚举、注解/file-20250213231740965.png)

3. @Deprecated注解
 
 ![](assets/09内部类、枚举、注解/file-20250213232043480.png)
 ![](assets/09内部类、枚举、注解/file-20250213232254535.png)
 ![](assets/09内部类、枚举、注解/file-20250213232115758.png)
![](assets/09内部类、枚举、注解/file-20250213232147691.png)

4. @SuppressWarnings注解
![](assets/09内部类、枚举、注解/file-20250213232545412.png)
![](assets/09内部类、枚举、注解/file-20250213232801604.png)
![](assets/09内部类、枚举、注解/file-20250213232836103.png)
![](assets/09内部类、枚举、注解/file-20250213232922495.png)
![](assets/09内部类、枚举、注解/file-20250213233017562.png)

### 2.元注解
![](assets/09内部类、枚举、注解/file-20250214095355509.png)
1. @Retention元注解  

![](assets/09内部类、枚举、注解/file-20250214095626008.png)
![](assets/09内部类、枚举、注解/file-20250214095804550.png)

2.@Target元注解 

![](assets/09内部类、枚举、注解/file-20250214100038800.png)

3.@Documented元注解

![](assets/09内部类、枚举、注解/file-20250214100241675.png)

4.@Inheriteds注解

![](assets/09内部类、枚举、注解/file-20250214100517035.png)