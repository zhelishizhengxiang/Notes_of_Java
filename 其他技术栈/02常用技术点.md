# 一、JWT令牌
注：会话跟踪技术传统的是使用cookie和session来进行解决。**但是实际上企业项目开发中会话跟踪技术的解决方案为JWT令牌。**

**jwt主流的原因：cookie无法进行跨域传输(前后端分离项目部署在不同服务器上)；session在微服务系统下，服务器集群部署负载均衡无法直接获取session**

后面的介绍是基于前后端分离架构来进行讨论的

![](assets/02常用技术点/file-20251225132959885.png)
* 能解决集群环境下的认证问题：  
	![](assets/02常用技术点/file-20251225151743176.png) 

## 1.JWT令牌介绍
![](assets/02常用技术点/file-20251225133723065.png)
![](assets/02常用技术点/file-20251225133949025.png)
* header和payload是base64编码，数字签名是对二者进行加密后的结果附在后面，并不是base64编码
* **令牌长度并不固定，原始内容越大，base64编码形成的字符串越长，令牌长度越长**

## 2.JWT令牌的使用
![](assets/02常用技术点/file-20251225134418742.png)
* builder()实际上就是使用的是建造者模式。
* signwith()方法适用于设置头部行的，其参数分别为数字签名的算法和对应算法经过base64编码的密钥。
* addclaims()用于设置有效载荷及自定义信息，内部接受一个map，map中存储自定义信息
* setExpiration()用于设置该令牌的有效期。
* compact()用于直接生成该jwt令牌


![](assets/02常用技术点/file-20251225134500260.png)
* parser用于进行解码，其含义就为解析，同样使用建造者模式。
* setSigningKey()就是用于设置数字签名算法对应的密钥
* parseClaimsJws()用于解析jwt令牌，并返回对应的解析过后的字符串令牌结果。
* getBody()就是用于获取解析后令牌的有效载荷，即自定义信息和默认信息。会返回Claims对象，其中就封装了有效载荷，本质就是一个map
* 注：如果令牌解析失败，则会抛出MalformedJwtException；如果令牌解析成功但是令牌已经过期，则会抛出ExpiredJwtException

### 3.JWT令牌的应用——登录案例
![](assets/02常用技术点/file-20251225141707380.png)
![](assets/02常用技术点/file-20251225142000664.png)
![](assets/02常用技术点/file-20251225142010244.png)

生成令牌，返回前端：  
![](assets/02常用技术点/file-20251225142132341.png)
![](assets/02常用技术点/file-20251225142433834.png)
* 401 状态码（HTTP 401 Unauthorized，官方名称为 “未授权”）是**HTTP 响应状态码中的客户端错误码**。  
	![](assets/02常用技术点/file-20251225142705789.png)

校验令牌通过拦截器：如果发现未登录则返回401状态码，由前端来进行跳转到登录页面的操作。  
![](assets/02常用技术点/file-20251225145017101.png)
![](assets/02常用技术点/file-20251225145317063.png)
![](assets/02常用技术点/file-20251225150814711.png)
![](assets/02常用技术点/file-20251225150944537.png)
![](assets/02常用技术点/file-20251225151000619.png)
* 实际上配置拦截路径时可以直接设置没有登录页面就即可，无需在拦截器中判断

# 二、Swagger

## 1.介绍
![](assets/02常用技术点/file-20251227142329274.png)

## 2.使用方式
![](assets/02常用技术点/file-20251227142546571.png)
![](assets/02常用技术点/file-20251227142709606.png)![](assets/02常用技术点/file-20251227143152313.png)
* `doc.html` 正是 **Swagger UI 的入口页面**，查看接口文档就访问该页面。`webjars` 是 **前端资源的 Jar 包管理方式**。必须配置好响应的映射指定的类路径下面，这样才可以**让项目能正常访问 Swagger UI 的页面和静态资源**。


## 3.常用注解
![](assets/02常用技术点/file-20251227145150642.png)

# 三、PageHelper
![](assets/02常用技术点/file-20251227195314225.png)![](assets/02常用技术点/file-20251227195356266.png)
![](assets/02常用技术点/file-20251227195434074.png)![](assets/02常用技术点/file-20251227195525588.png)
![](assets/02常用技术点/file-20251227195606314.png)
* 以上是最新版PageHelper插件的api用法，下面是旧版，只是api进行了改编，其余不变。  
	![](assets/02常用技术点/file-20251227201635961.png)

# 四、日期格式处理

对于从数据库中查找的时间是以Json直接传输给其前端，并且可能会是如下图的效果，时间属性传输是以数组形式传输，导致前端展示时错误。不是我们想要的时分秒形式。

![](assets/02常用技术点/file-20251227203400853.png)
![](assets/02常用技术点/file-20251227203426228.png)


解决方案：    
![](assets/02常用技术点/file-20251227203554880.png)
![[file-20251228140442674.png]]
* 为了代码的可扩展性，推荐推荐使用方式二。

修改以后的效果：   
![](assets/02常用技术点/file-20251227203721062.png)
* create_time是修改后的，UpdateTime是未修改的。

# 五、公共字段自动填充

**适用于：多个表中都有公共字段的情况**

![[file-20251228130722112.png]]
* 插入新实体时，都会进行如上图的代码，就会产生很多冗余的代码。若后期表结构发生改变，则所有代码都需要进行修改。

**解决思路：试用AOP切面的思想来进行修改**   
![[file-20251228131120391.png]]


