### 执行流程综述
以下是核心代码：
```java
public class DispatcherServlet extends FrameworkServlet {
	/// 前端控制器最核心的方法，这个方法是负责处理请求的，一次请求，调用一次 doDispatch 方法。
    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
        // 根据请求对象request获取处理器链条（包括控制器和拦截器）
        // 这个对象是在每次发送请求时都创建一个，是请求级别的
        // 实际上返回的是一个处理器执行链对象。这个执行链(链条)把谁串起来了呢？把这一次请求要执行的所有拦截器和处理器串起来了。
        // HandlerExecutionChain是一次请求对应一个对象
        HandlerExecutionChain mappedHandler = getHandler(request);

        // 根据处理器获取处理器适配器。（底层使用了适配器模式）
        // HandlerAdapter在web服务器启动的时候就创建好了。（启动时创建多个HandlerAdapter放在List集合中）
        // HandlerAdapter有多种类型：
        // RequestMappingHandlerAdapter：用于适配使用注解 @RequestMapping 标记的控制器方法
        // SimpleControllerHandlerAdapter：用于适配实现了 Controller 接口的控制器
        // 注意：此时还没有进行数据绑定（也就是说，表单提交的数据，此时还没有转换为pojo对象。）
        HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());//// Handler就是我们写的Controller

        // 执行请求对应的所有拦截器中的 preHandle 方法，具体可以看之前在拦截器的源码分析
        if (!mappedHandler.applyPreHandle(processedRequest, response)) {
            return;
        }

        // 通过处理器适配器调用处理器（控制器）方法
        // 在调用处理器方法之前会进行数据绑定，将表单提交的数据绑定到处理器方法上。（底层是通过WebDataBinder完成的）
        // 要传参的话，这个参数实际上是要经过一个复杂的数据绑定过程（将前端提交的表单数据转换成POJO对象），会使用：HttpMessageConverter
        // 结束后返回ModelAndView对象
        mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

        //  执行请求对应的所有拦截器中的 postHandle 方法，具体可以看之前在拦截器的源码分析
        mappedHandler.applyPostHandle(processedRequest, response, mv);

        // 处理分发结果（在这个方法中完成了响应），之前讲过，详细看前面视图机制的原理
        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
    }


    // 根据每一次的请求对象来获取处理器执行链对象
    protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
		if (this.handlerMappings != null) {
            // HandlerMapping在服务器启动的时候就创建好了，放到了List集合中。HandlerMapping也有多种类型
            // RequestMappingHandlerMapping：将 URL 映射到使用注解 @RequestMapping 标记的控制器方法的处理器。
            // SimpleUrlHandlerMapping：将 URL 映射到处理器中指定的 URL 或 URL 模式的处理器。
			for (HandlerMapping mapping : this.handlerMappings) {
                // 重点：这是一次请求的开始，实际上是通过处理器映射器来获取的处理器执行链对象
                // 底层实际上会通过 HandlerMapping 对象获取 HandlerMethod对象，将HandlerMethod 对象传递给 HandlerExecutionChain对象。
                // 注意：HandlerMapping对象和HandlerMethod对象都是在服务器启动阶段创建的。
                // RequestMappingHandlerMapping对象中有多个HandlerMethod对象。
				HandlerExecutionChain handler = mapping.getHandler(request);
				if (handler != null) {
					return handler;
				}
			}
		}
		return null;
	}


    private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
			@Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,
			@Nullable Exception exception) throws Exception {
        // 渲染视图
        render(mv, request, response);
        // 渲染完毕后，调用该请求对应的所有拦截器的 afterCompletion方法，详情看拦截器章节
        mappedHandler.triggerAfterCompletion(request, response, null);
    }

    protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {
        // 将逻辑视图转换成物理视图的路径名，通过视图解析器返回视图对象
        view = resolveViewName(viewName, mv.getModelInternal(), locale, request);
        // 真正的渲染视图
        view.render(mv.getModelInternal(), request, response);
    }

    protected View resolveViewName(String viewName, @Nullable Map<String, Object> model,
			Locale locale, HttpServletRequest request) throws Exception {
        // 通过视图解析器返回视图对象
        View view = viewResolver.resolveViewName(viewName, locale);
	}
}
```

```java
// 视图解析器接口实现类也很多：ThymeleafViewResolver、InternalResourceViewResolver
public interface ViewResolver {
    View resolveViewName(String viewName, Locale locale) throws Exception;
}
```

```java
// 视图接口
public interface View {
    void render(@Nullable Map<String, ?> model, HttpServletRequest request, HttpServletResponse response)
			throws Exception;
}
```

### 分析处理器执行链

```java
分析这一行代码：
HandlerExecutionChain mappedHandler = getHandler(request);

1. HandlerExecutionChain：处理器执行链对象
2. HandlerExecutionChain中的属性：
    public class HandlerExecutionChain{
        // 底层对应的是一个HandlerMethod对象
        // 处理器（即控制器）方法对象
        Object handler = new HandlerMethod(.....);
        // 该请求对应的所有的拦截器按照顺序放到了ArrayList集合中
        // 所有的拦截器对象也都是在服务器启动的时候都创建好。
        List<HandlerInterceptor> interceptorList;
    }

3. HandlerMethod 是什么？
    HandlerMethod是最核心的要执行的目标，翻译为：处理器方法。
    注意：HandlerMethod 是在web服务器启动时初始化spring容器的时候，就创建好了。
    这个类当中比较重要的属性包括：beanName和Method
    例如，以下代码：
        @Controller("userController")
        public class UserController{
            @RequestMapping("/login")
            public String login(User user){
                return ....
            }
        }
    那么以上代码对应了一个HandlerMethod对象：
        public class HandlerMethod{
            private String beanName = "userController";
            private Method loginMethod;
        }

4. getHandler(request);
    这个方法还是在DispatcherServlet类中。
    protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
        if (this.handlerMappings != null) {
            for (HandlerMapping mapping : this.handlerMappings) {
                // 通过合适的 HandlerMapping才能获取到 HandlerExecutionChain对象。
                // 如果你处理器方法使用了 @RequestMapping注解，那么以下代码中最终获得的mapping是：RequestMappingHandlerMapping对象。
                HandlerExecutionChain handler = mapping.getHandler(request);
                if (handler != null) {
                    return handler;
                }
            }
        }
        return null;
    }

    重点：
        我们处理请求的第一步代码是：HandlerExecutionChain mappedHandler = getHandler(request);
        其本质上是调用了：HandlerExecutionChain handler = mapping.getHandler(request);

    mapping变量就是 HandlerMapping。
    HandlerMapping是一个接口：
        翻译为处理器映射器，专门负责映射的。就是本质上根据请求路径去映射处理器方法的。
        HandlerMapping接口下有很多实现类：
            例如其中一个比较有名的，常用的：RequestMappingHandlerMapping
            这个 RequestMappingHandlerMapping 叫做：@RequestMapping注解专用

            当然，如果你没有使用 @RequestMapping注解，也可以写xml配置文件来进行映射，那个时候对应的就是其他的HandlerMapping接口的实现类了。
   
    HandlerMapping 对象也是在服务器启动阶段创建的，所有的HandlerMapping对象都是在服务器启动阶段创建，并且存放到集合中。
    public class DispatcherServlet{
        List<HandlerMapping> handlerMappings;
    }

5. RequestMappingHandlerMapping中的 getHandler(request);
    HandlerExecutionChain handler = mapping.getHandler(request);
    
    mapping.getHandler(request);这个方法底层一定是获取了 HandlerMethod 对象，将其赋值给 HandlerExecutionChain的handler属性

    public class RequestMappingHandlerMapping extends AbstractHandlerMethodMapping{
        protected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping) {
            super.registerHandlerMethod(handler, method, mapping);
            updateConsumesCondition(mapping, method);
        }
    }

    public class AbstractHandlerMethodMapping{
        protected void registerHandlerMethod(Object handler, Method method, T mapping) {
            this.mappingRegistry.register(mapping, handler, method);
        }

        public void register(T mapping, Object handler, Method method) {
            HandlerMethod handlerMethod = createHandlerMethod(handler, method);
        }

        protected HandlerMethod createHandlerMethod(Object handler, Method method) {
            if (handler instanceof String beanName) {
                return new HandlerMethod(beanName,
                        obtainApplicationContext().getAutowireCapableBeanFactory(),
                        obtainApplicationContext(),
                        method);
            }
            return new HandlerMethod(handler, method);
        }
    }
    

这一步牵连到的类有哪些：
    HandlerExecutionChain
    HandlerMethod
    HandlerInterceptor
    HandlerMapping
        RequestMappingHandlerMapping（是HandlerMaping接口的实现）
```

### 分析处理器适配器对象

```java
分析：
HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

1. 底层使用了适配器模式。

2. 每一个处理器(我们自己写的Controller)，都有自己适合的处理器适配器。

3. 在SpringMVC当中处理器适配器也有很多种，其中一个比较有名的，常用的处理器适配器是：RequestMappingHandlerAdapter
这个处理器适配器是专门处理 “处理器方法”上有 @RequestMapping 注解的。

4. mappedHandler.getHandler() 获取的是 HandlerMethod 对象,mappedHandler是HandlerExecutionChain处理器执行链对象

5. HandlerAdapter也是一个接口：
    其中有一个常用的实现类：RequestMappingHandlerAdapter

6. 在服务器启动阶段，所有的 HandlerAdapter接口的实现类都会创建出来。在服务器启动阶段！！！！！！
    List<HandlerAdapter> handlerAdapters;

7. HandlerAdapter接口非常重要，通过这个接口来调用最终的 HandlerMethod。

8. HandlerAdapter是适配器，是对 HandlerMethod 进行的适配。

9. 在DispatcherServlet类中，如下代码：
    protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {
        if (this.handlerAdapters != null) {
            for (HandlerAdapter adapter : this.handlerAdapters) {
                if (adapter.supports(handler)) {
                    return adapter;
                }
            }
        }
    }
```


### 调用处理器方法
```java
关于调用处理器方法：
    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

    ha 是处理器适配器

    mv 是ModelAndView对象

    这个方法是最核心的，调用请求路径对应的HandlerMethod。（调用处理器方法。）。
    
    mappedHandler.getHandler()用于获得请求路径对应的HandlerMethod


ha是HandlerAdapter，如果是 @RequestMapping 注解对应的，那么就是 RequestMappingHandlerAdapter：

RequestMappingHandlerAdapter：
    protected ModelAndView handleInternal(HttpServletRequest request,
                HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {
        mav = invokeHandlerMethod(request, response, handlerMethod);
    }
      
    protected ModelAndView invokeHandlerMethod(HttpServletRequest request,
            HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {
        // 获取一个数据绑定工厂
        WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);
        // 获取一个可调用的处理器方法
        ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);
        // 给可调用的方法绑定数据
        invocableMethod.setDataBinderFactory(binderFactory);
        // 给可调用的方法设置参数
        invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);
        // 可调用的方法执行了。
        invocableMethod.invokeAndHandle(webRequest, mavContainer);
    }

在HandlerAdapter中做的核心事情：
    将前端提交的form数据通过 HttpMessageConverter 将其转换成 POJO对象。（数据转换）
    并将数据绑定到 HandlerMethod 对象上。
    调用HandlerMethod。
    返回 ModelAndView


```