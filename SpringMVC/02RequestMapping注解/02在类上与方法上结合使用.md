我们先来看，在同一个web应用中，是否可以有两个完全一样的RequestMapping。

测试一下：假设两个RequestMapping，其中一个是展示用户详细信息，另一个是展示商品详细信息。提供两个Controller，一个是UserController，另一个是ProductController。如下：
```java
package com.powernode.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

/**
 * ClassName: UserController
 * Description:
 * Datetime: 2024/3/13 16:40
 * Author: 老杜@动力节点
 * Version: 1.0
 */
@Controller
public class UserController {
    @RequestMapping("/detail")
    public String toDetail(){
        return "detail";
    }
}

```
```java
package com.powernode.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

/**
 * ClassName: ProductController
 * Description:
 * Datetime: 2024/3/13 16:40
 * Author: 老杜@动力节点
 * Version: 1.0
 */
@Controller
public class ProductController {
    @RequestMapping("/detail")
    public String toDetail(){
        return "detail";
    }
}

```
以上两个Controller的RequestMapping相同，都是"/detail"，我们来启动服务器看会不会出现问题：异常发生了，异常信息如下
```java
org.springframework.beans.factory.BeanCreationException: 
Error creating bean with name 'org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping': 
Ambiguous mapping. Cannot map 'userController' method 
com.powernode.springmvc.controller.UserController#toDetail()
to { [/detail]}: There is already 'productController' bean method
com.powernode.springmvc.controller.ProductController#toDetail() mapped.
```
以上异常信息大致的意思是：不明确的映射。无法映射UserController中的toDetail()方法，因为已经在ProductController中映射过了！！！！

通过测试得知，**在同一个webapp中，RequestMapping必须具有唯一性。怎么解决以上问题？两种解决方案：**
- 第一种方案：将方法上RequestMapping的映射路径修改的不一样。
- **第二种方案：在类上添加RequestMapping的映射路径，以类上的RequestMapping作为命名空间，来加以区分两个不同的映射**。

## 第一种方案
将方法上RequestMapping的映射路径修改的不一样。
```java
@RequestMapping("/user/detail")
public String toDetail(){
    return "/user/detail";
}
```
```java
@RequestMapping("/product/detail")
public String toDetail(){
    return "/product/detail";
}
```
再次启动web服务器，会发现没有再报错了。
为这两个请求分别提供对应的视图页面：

![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710321603074-a058da54-46c1-45c2-9a16-08759212e879.png#averageHue=%23ecf0f9&clientId=u536eeef9-a13d-4&from=paste&height=218&id=u5429a195&originHeight=218&originWidth=301&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12656&status=done&style=none&taskId=ud67c1285-e182-45fd-901a-220c180f602&title=&width=301)
```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>商品详情页面</title>
</head>
<body>
<h1>商品详情</h1>
</body>
</html>
```
```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>用户详情页面</title>
</head>
<body>
<h1>用户详情</h1>
</body>
</html>
```
在首页面添加两个超链接：
```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>index page</title>
</head>
<body>
<h1>index page</h1>
<a th:href="@{/user/detail}">用户详情</a><br>
<a th:href="@{/product/detail}">商品详情</a><br>
</body>
</html>
```
**Thymeleaf检测到以 / 开始，表示绝对路径，自动会将webapp的上下文路径加上去。最终的效果是：href="/springmvc/other**

启动Tomcat服务器，并测试：http://localhost:8080/springmvc/  
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710321765401-8615ea50-6537-4a23-9c28-e91cf8d3a957.png#averageHue=%23f9f8f8&clientId=u536eeef9-a13d-4&from=paste&height=257&id=u543e5fcb&originHeight=257&originWidth=398&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13138&status=done&style=none&taskId=u21bda0b6-2b24-4cf4-b8e0-24407d75886&title=&width=398)
点击用户详情，点击商品详情，都可以正常显示：  
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710323998528-e38bedfd-8915-4dd5-a5ff-47c7f65df143.png#averageHue=%23d5b281&clientId=ub006eeb4-d5e7-4&from=paste&height=219&id=u353f7f40&originHeight=219&originWidth=493&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11545&status=done&style=none&taskId=ub7bf346b-8e18-48bf-b338-5cf89bc4193&title=&width=493)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710324010676-719ba465-0cc1-49bf-a9e6-3d1375dfdc65.png#averageHue=%23f7f7f6&clientId=ub006eeb4-d5e7-4&from=paste&height=241&id=u66baa171&originHeight=241&originWidth=402&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11385&status=done&style=none&taskId=u0a5f7eac-1eca-44f3-bfeb-93abbb39cb4&title=&width=402)


## 第二种方案

* **在类上和方法上都使用RequestMapping注解来进行路径的映射。假设在类上映射的路径是"/a"，在方法上映射的路径是"/b"，那么整体表示映射的路径就是："/a/b"**
* **在第一种方案中，假设UserController类中有很多方法，每个方法的 RequestMapping注解中都需要以"/user"开始，显然比较啰嗦，干脆将"/user"提升到类级别上，例如：**
```java
package com.powernode.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

/**
 * ClassName: UserController
 * Description:
 * Datetime: 2024/3/13 16:40
 * Author: 老杜@动力节点
 * Version: 1.0
 */
@Controller
@RequestMapping("/user")
public class UserController {
    @RequestMapping("/detail")
    public String toDetail(){
        return "/user/detail";
    }
}

```
```java
package com.powernode.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

/**
 * ClassName: ProductController
 * Description:
 * Datetime: 2024/3/13 16:40
 * Author: 老杜@动力节点
 * Version: 1.0
 */
@Controller
@RequestMapping("/product")
public class ProductController {
    @RequestMapping("/detail")
    public String toDetail(){
        return "/product/detail";
    }
}

```
经过测试，程序可以正常执行！！！

