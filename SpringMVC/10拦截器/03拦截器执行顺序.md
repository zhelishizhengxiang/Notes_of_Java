
## 一、执行顺序
### 1.如果所有拦截器preHandle都返回true

**按照springmvc.xml文件中配置的顺序，自上而下调用 preHandle：**
```xml
<mvc:interceptors>
    <ref bean="interceptor1"/>
    <ref bean="interceptor2"/>
</mvc:interceptors>
```
执行顺序：  
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1711680479220-91b54971-fc52-47b6-a711-4425dfa1617a.png#averageHue=%233d2c2b&clientId=u7722411a-d657-4&from=paste&height=169&id=u13f6736b&originHeight=169&originWidth=419&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18938&status=done&style=shadow&taskId=u44f0965a-a336-4022-9dd8-d419ee7e712&title=&width=419)

 
### 2.如果其中一个拦截器preHandle返回false
```xml
<mvc:interceptors>
    <ref bean="interceptor1"/>
    <ref bean="interceptor2"/>
</mvc:interceptors>
```
如果`interceptor2`的preHandle返回false，执行顺序：  

![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1711680589053-dbc8883c-eabe-476c-a8f3-da24b4f8de70.png#averageHue=%233b2e2c&clientId=u7722411a-d657-4&from=paste&height=88&id=u52dd80be&originHeight=88&originWidth=356&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9244&status=done&style=shadow&taskId=u0ce55354-58d4-4a99-9eb6-d90ea484cae&title=&width=356)

**规则：只要有一个拦截器`preHandle`返回false，任何`postHandle`都不执行。但返回false的拦截器的前面的拦截器按照逆序执行`afterCompletion`。**


## 二、源码分析
DispatcherServlet和 HandlerExecutionChain的部分源码：
```java
public class DispatcherServlet extends FrameworkServlet {
    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
        // 按照顺序执行所有拦截器的preHandle方法
        if (!mappedHandler.applyPreHandle(processedRequest, response)) {
            return;
        }
        // 执行处理器方法
        mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
        // 按照逆序执行所有拦截器的 postHanle 方法
        mappedHandler.applyPostHandle(processedRequest, response, mv);
        // 处理视图
        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
    }

    private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
			@Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,
			@Nullable Exception exception) throws Exception {
        // 渲染视图
        render(mv, request, response);
        // 按照逆序执行所有拦截器的 afterCompletion 方法
        mappedHandler.triggerAfterCompletion(request, response, null);
    }
}
```
```java
public class HandlerExecutionChain {
    // 顺序执行 preHandle
    boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {
        for (int i = 0; i < this.interceptorList.size(); i++) {
            HandlerInterceptor interceptor = this.interceptorList.get(i);
            if (!interceptor.preHandle(request, response, this.handler)) {
                // 如果其中一个拦截器preHandle返回false
                // 将该拦截器前面的拦截器按照逆序执行所有的afterCompletion
                triggerAfterCompletion(request, response, null);
                return false;
            }
            //会把书匈奴执行的i的值不断更新到该index中
            this.interceptorIndex = i;
        }
        return true;
	}
    // 逆序执行 postHanle
    void applyPostHandle(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv) throws Exception {
        for (int i = this.interceptorList.size() - 1; i >= 0; i--) {
            HandlerInterceptor interceptor = this.interceptorList.get(i);
            interceptor.postHandle(request, response, this.handler, mv);
        }
	}
    // 逆序执行 afterCompletion
	void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex) {
		for (int i = this.interceptorIndex; i >= 0; i--) {
			HandlerInterceptor interceptor = this.interceptorList.get(i);
			try {
				interceptor.afterCompletion(request, response, this.handler, ex);
			}
			catch (Throwable ex2) {
				logger.error("HandlerInterceptor.afterCompletion threw exception", ex2);
			}
		}
	}
}
```


