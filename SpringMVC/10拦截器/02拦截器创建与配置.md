
## 一、定义拦截器

**实现`org.springframework.web.servlet.HandlerInterceptor` 接口，共有三个方法可以进行选择性的实现**：
- **preHandle：处理器方法调用之前执行**
   - **只有该方法有返回值，返回值是布尔类型，true放行，false拦截。相当于不会执行处理器方法以及后哦面的内容直接返回**
- **postHandle：处理器方法调用之后执行**
- **afterCompletion：渲染完成后执行**


## 二、拦截器基本配置
**默认情况下，拦截器是拦截所有请求的。**

在springmvc.xml文件中进行如下配置：  
第一种方式：
```xml
<mvc:interceptors>
    <bean class="com.powernode.springmvc.interceptors.Interceptor1"/>
</mvc:interceptors>
```

第二种方式：
```xml
<mvc:interceptors>
    <ref bean="interceptor1"/>
</mvc:interceptors>
```
第二种方式的前提：
- 前提1：包扫描  
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1711677116557-070845c1-bae7-4769-98c9-b064faffc4c6.png#averageHue=%23302b2a&clientId=u7722411a-d657-4&from=paste&height=85&id=u9e3b136b&originHeight=85&originWidth=1171&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11909&status=done&style=shadow&taskId=u9ee38d99-2461-48e5-8d77-d2a85387fae&title=&width=1171)
- 前提2：使用 @Component 注解进行标注  
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1711677132812-77ff787c-8f94-41d6-abd8-721037ff0160.png#averageHue=%23322d2b&clientId=u7722411a-d657-4&from=paste&height=106&id=u059bcc9b&originHeight=106&originWidth=603&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13193&status=done&style=shadow&taskId=ufa06cd99-c4b3-4bfc-ac2e-bece3e2f1f0&title=&width=603)



## 三、拦截器部分源码分析
### 1.方法执行顺序的源码分析
```java
public class DispatcherServlet extends FrameworkServlet {
    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
        // 调用所有拦截器的 preHandle 方法
        if (!mappedHandler.applyPreHandle(processedRequest, response)) {
            return;
        }
        // 调用处理器方法
        mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
        // 调用所有拦截器的 postHandle 方法
        mappedHandler.applyPostHandle(processedRequest, response, mv);
        // 处理视图
        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
    }

    private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
			@Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,
			@Nullable Exception exception) throws Exception {
        // 渲染页面
        render(mv, request, response);
        // 调用所有拦截器的 afterCompletion 方法
        mappedHandler.triggerAfterCompletion(request, response, null);
    }
}
```


### 2.拦截与放行的源码分析
```java
public class DispatcherServlet extends FrameworkServlet {
    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
        // 调用所有拦截器的 preHandle 方法
        if (!mappedHandler.applyPreHandle(processedRequest, response)) {
            // 如果 mappedHandler.applyPreHandle(processedRequest, response) 返回false，以下的return语句就会执行
            return;
        }
    }
}
```
```java
public class HandlerExecutionChain {
    boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {
	    //可以配置多个拦截器，所以这里的list放的是所有的拦截器
		for (int i = 0; i < this.interceptorList.size(); i++) {
			HandlerInterceptor interceptor = this.interceptorList.get(i);
			// 如果 interceptor.preHandle(request, response, this.handler) 返回 false，以下的 return false;就会执行。
			if (!interceptor.preHandle(request, response, this.handler)) {
				triggerAfterCompletion(request, response, null);
				return false;
			}
			this.interceptorIndex = i;
		}
		return true;
	}
}
```

# 四、拦截器的高级配置
采用以上基本配置方式，拦截器是拦截所有请求路径的。如果要针对某些路径进行拦截，某些路径不拦截，可以采用高级配置：
```xml
<mvc:interceptors>
    <mvc:interceptor>
        <!--拦截所有路径-->
        <mvc:mapping path="/**"/>
        <!--除 /test 路径之外-->
        <mvc:exclude-mapping path="/test"/>
        <!--拦截器-->
        <ref bean="interceptor1"/>
    </mvc:interceptor>
</mvc:interceptors>
```
以上的配置表示，除 /test 请求路径之外，剩下的路径全部拦截。

