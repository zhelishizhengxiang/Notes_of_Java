
## 1.get请求乱码
get请求数据在URI后面提交，这个乱码问题怎么解决呢？  
* **解决办法是找到 CATALINA_HOME/config/server.xml文件，找到其中配置端口号的标签\<Connector>，在该标签中添加  URIEncoding="UTF-8"。但是对于高版本的Tomcat服务器来说，是不需要设置的，例如Tomcat10，Tomcat9，有如下的默认配置，在默认情况下URIEncoding使用的就是UTF-8的编码方式**。  
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710480361252-0f3431f2-906f-41ea-b4b9-ac9dba2d926a.png#averageHue=%23c9dff1&clientId=u9c5ec896-edd3-4&from=paste&height=375&id=u56378d90&originHeight=375&originWidth=1127&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68507&status=done&style=shadow&taskId=u67ba8020-6dfc-447c-968e-2d58ec2d750&title=&width=1127)

**但对于低版本的Tomcat服务器，例如：Tomcat8。URIEncoding的默认配置是ISO-8859-1**，因此在Tomcat8中需要手动配置server.xml文件：  
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710480799719-41567287-3dcb-441b-853f-15114b8c2216.png#averageHue=%23eef4fb&clientId=u9c5ec896-edd3-4&from=paste&height=346&id=u82f7afb0&originHeight=346&originWidth=762&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41871&status=done&style=shadow&taskId=uef26f821-2f5a-4786-984a-9ca3b1bf9fe&title=&width=762)
配置如下：    
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710480903724-206fb06c-4cff-4ed0-a24b-83ceefb65d79.png#averageHue=%23f9f4f2&clientId=u9c5ec896-edd3-4&from=paste&height=292&id=u480fdc4d&originHeight=292&originWidth=451&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23728&status=done&style=shadow&taskId=ua46057d5-9b99-4e72-b0e9-cbc8655c3c4&title=&width=451)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710480932430-381979d9-289d-4c8a-abc7-653e824c8753.png#averageHue=%23fdfaf8&clientId=u9c5ec896-edd3-4&from=paste&height=148&id=u98600f2b&originHeight=148&originWidth=707&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15301&status=done&style=shadow&taskId=ue3b70f18-d7b5-44a4-a986-d1766fbada2&title=&width=707)



接下来，我们测试一下，在默认情况下，Tomcat10是否已经解决了get请求乱码问题：
```html
<form th:action="@{/register}" method="get">
    用户名：<input type="text" name="username"><br>
    密码：<input type="password" name="password"><br>
    性别：
        男 <input type="radio" name="sex" value="1">
        女 <input type="radio" name="sex" value="0">
        <br>
    爱好：
        抽烟 <input type="checkbox" name="hobby" value="smoke">
        喝酒 <input type="checkbox" name="hobby" value="drink">
        烫头 <input type="checkbox" name="hobby" value="perm">
        <br>
    简介：<textarea rows="10" cols="60" name="intro"></textarea><br>
    <input type="submit" value="注册">
</form>
```
注意，以上表单已经修改为get请求了。
```java
@GetMapping("/register")
public String register(User user){
    System.out.println(user);
    return "success";
}
```
测试结果：  
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710481129146-18d9e4e2-8385-423a-adc5-3d379323cbb7.png#averageHue=%23fbf9f9&clientId=u9c5ec896-edd3-4&from=paste&height=353&id=u7dd03e01&originHeight=353&originWidth=547&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11182&status=done&style=shadow&taskId=ucb980289-2641-4aee-a8da-39eb044013d&title=&width=547)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710481146376-640c0e7f-6872-453a-b3ea-b34b899bf16d.png#averageHue=%23d6b687&clientId=u9c5ec896-edd3-4&from=paste&height=212&id=u4695c042&originHeight=212&originWidth=1167&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18475&status=done&style=shadow&taskId=ucf68979f-2344-4438-9b8b-9395f5103fd&title=&width=1167)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710481162744-dba51e29-fadf-4d68-a79c-50f9fb3e951b.png#averageHue=%23f8f2ef&clientId=u9c5ec896-edd3-4&from=paste&height=84&id=ucc20b11b&originHeight=84&originWidth=1181&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23594&status=done&style=shadow&taskId=ue6a609ec-37e2-4ffa-a300-47e3e379179&title=&width=1181)

## 2.post请求乱码
 * **post请求是解决请求体的中文乱码问题。解决办法大家都知道**：
```java
request.setCharacterEncoding("UTF-8");
```

同样，**对于高版本的**Tomcat10**服务器来说，针对请求体中的字符编码也是配置好的，默认也是采用了UTF-8，中文乱码问题也解决了，在这个文件中配置的：apache-tomcat-10.1.19\conf\web.xml**

配置内容如下：       
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710731491577-383b3f5b-046a-47c4-8da9-86b52ab1f535.png#averageHue=%23fcfcf9&clientId=uaa027169-bbba-4&from=paste&height=118&id=u554f4f5b&originHeight=118&originWidth=1038&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12763&status=done&style=shadow&taskId=ua54535d4-a1c1-4416-bd44-1caf5ba6a70&title=&width=1038)

通过以上配置可以看到，Tomcat10对请求和响应都设置了默认的字符编码方式为UTF-8
**一定要注意：Tomcat9以及之前的版本，以上的配置是没有的。**

我们来测试一下，针对Tomcat10来说，SpringMVC会不会有乱码问题：  
```html
<form th:action="@{/register}" method="post">
    用户名：<input type="text" name="username"><br>
    密码：<input type="password" name="password"><br>
    性别：
        男 <input type="radio" name="sex" value="1">
        女 <input type="radio" name="sex" value="0">
        <br>
    爱好：
        抽烟 <input type="checkbox" name="hobby" value="smoke">
        喝酒 <input type="checkbox" name="hobby" value="drink">
        烫头 <input type="checkbox" name="hobby" value="perm">
        <br>
    简介：<textarea rows="10" cols="60" name="intro"></textarea><br>
    <input type="submit" value="注册">
</form>
```
注意：以上表单已经修改为post请求
```java
@PostMapping("/register")
public String register(User user, HttpServletRequest request) throws UnsupportedEncodingException {
    System.out.println(user);
    return "success";
}
```
测试结果：  
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710481669556-b01327ea-202b-42b7-8f65-5d0d5fabe764.png#averageHue=%23f8f8f7&clientId=u9c5ec896-edd3-4&from=paste&height=351&id=yzBYT&originHeight=351&originWidth=525&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11158&status=done&style=shadow&taskId=u16a83f4f-6aad-42f1-ba06-b4944844b67&title=&width=525)



![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710731963626-7c6e6d8c-a222-4588-b17d-5dafe2923abb.png#averageHue=%23d5b07e&clientId=uaa027169-bbba-4&from=paste&height=202&id=uefbb20b6&originHeight=202&originWidth=458&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12508&status=done&style=shadow&taskId=ue14d1f18-d66d-405b-a146-35421e45ce7&title=&width=458)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710731980833-96d1f7fe-aae4-48e9-b876-0b233834f563.png#averageHue=%23f7e8e5&clientId=uaa027169-bbba-4&from=paste&height=98&id=u38f2b40e&originHeight=98&originWidth=1158&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28986&status=done&style=shadow&taskId=u34c57d0d-18f0-42aa-95d9-39b68a6cd36&title=&width=1158)

通过测试可以看到在Tomcat10当中，默认SpringMVC，发送POST请求，是不会出现乱码问题的。

有可能很多同学使用的不是Tomcat10，如果不是Tomcat10，则会出现乱码问题，我们来模拟一下乱码的产生，将apache-tomcat-10.1.19\conf\web.xml文件中的UTF-8配置修改为ISO-8859-1：  
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710732413713-0f034192-e4d4-4c33-aeb3-169726468251.png#averageHue=%23fbfaf6&clientId=uaa027169-bbba-4&from=paste&height=100&id=u2e406be6&originHeight=100&originWidth=1076&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14164&status=done&style=shadow&taskId=u29422620-4508-4e2a-b9f9-55883186649&title=&width=1076)

**一定要重启Tomcat10**，新的配置才能生效，来测试一下是否存在乱码：  
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710732483068-b356942a-9183-4734-812d-041a151df48d.png#averageHue=%23f7f3ef&clientId=uaa027169-bbba-4&from=paste&height=107&id=u6f629e75&originHeight=107&originWidth=1261&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29572&status=done&style=shadow&taskId=uf4ea95b7-d40b-450f-8c09-94e4531b65a&title=&width=1261)

## 3.过滤器解决post乱码问题
* **解决post乱码问题不能依赖tomcat服务器版本，因为有些人的tomcat他就不是10以上的。**
* **在SpringMVC中如何解决请求体的中文乱码问题呢？当然，还是使用`request.setCharacterEncoding("UTF-8")`。使用它有一个前提条件，要想解决请求体乱码问题，以上代码必须在 `request.getParameter("username")`执行之前执行才有效。**
* **也就是说以上代码如果放在Controller的相关方法中执行是无效的，因为Controller的方法在执行之前 DispatcherServlet已经调用了 `request.getParameter("username")`方法。因此在Controller方法中使用`request.setCharacterEncoding("UTF-8")`无效**
```html
<form th:action="@{/register}" method="post">
    用户名：<input type="text" name="username"><br>
    密码：<input type="password" name="password"><br>
    性别：
        男 <input type="radio" name="sex" value="1">
        女 <input type="radio" name="sex" value="0">
        <br>
    爱好：
        抽烟 <input type="checkbox" name="hobby" value="smoke">
        喝酒 <input type="checkbox" name="hobby" value="drink">
        烫头 <input type="checkbox" name="hobby" value="perm">
        <br>
    简介：<textarea rows="10" cols="60" name="intro"></textarea><br>
    <input type="submit" value="注册">
</form>
```
注意：以上表单已经修改为post请求
```java
@PostMapping("/register")
public String register(User user, HttpServletRequest request) throws UnsupportedEncodingException {
    request.setCharacterEncoding("UTF-8");
    System.out.println(user);
    return "success";
}
```


测试结果：   
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710481669556-b01327ea-202b-42b7-8f65-5d0d5fabe764.png#averageHue=%23f8f8f7&clientId=u9c5ec896-edd3-4&from=paste&height=351&id=uf9df1daa&originHeight=351&originWidth=525&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11158&status=done&style=shadow&taskId=u16a83f4f-6aad-42f1-ba06-b4944844b67&title=&width=525)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710732483068-b356942a-9183-4734-812d-041a151df48d.png#averageHue=%23f7f3ef&clientId=uaa027169-bbba-4&from=paste&height=107&id=prLSj&originHeight=107&originWidth=1261&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29572&status=done&style=shadow&taskId=uf4ea95b7-d40b-450f-8c09-94e4531b65a&title=&width=1261)

通过测试可以看到：在Controller当中调用`request.setCharacterEncoding("UTF-8")`是无法解决POST乱码问题的。

#### 使用内置过滤器解决post请求乱码问题

那怎么办呢？怎么样才能在DispatcherServlet之前执行`request.setCharacterEncoding("UTF-8")`呢？没错，我相信大家想到了：**过滤器Filter。过滤器Filter可以在Servlet执行之前执行**。有同学又说了：监听器不行吗？不行。因为我们需要对每一次请求解决乱码，而监听器只在服务器启动阶段执行一次。因此这里解决每一次请求的乱码问题，应该使用过滤器Filter。并且，告诉大家一个好消息，**SpringMVC已经将这个字符编码的过滤器提前写好了，为`CharacterEncodingFilter`。我们直接配置好即可**：  
![](assets/08请求的中文乱码问题/file-20250805115459721.png)

我们一起看一下它的源码：
```java
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.web.filter;

import java.io.IOException;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Servlet Filter that allows one to specify a character encoding for requests.
 * This is useful because current browsers typically do not set a character
 * encoding even if specified in the HTML page or form.
 *
 * <p>This filter can either apply its encoding if the request does not already
 * specify an encoding, or enforce this filter's encoding in any case
 * ("forceEncoding"="true"). In the latter case, the encoding will also be
 * applied as default response encoding (although this will usually be overridden
 * by a full content type set in the view).
 *
 * @author Juergen Hoeller
 * @since 15.03.2004
 * @see #setEncoding
 * @see #setForceEncoding
 * @see jakarta.servlet.http.HttpServletRequest#setCharacterEncoding
 * @see jakarta.servlet.http.HttpServletResponse#setCharacterEncoding
 */
public class CharacterEncodingFilter extends OncePerRequestFilter {

	@Nullable
	private String encoding;

	private boolean forceRequestEncoding = false;

	private boolean forceResponseEncoding = false;


	/**
	 * Create a default {@code CharacterEncodingFilter},
	 * with the encoding to be set via {@link #setEncoding}.
	 * @see #setEncoding
	 */
	public CharacterEncodingFilter() {
	}

	/**
	 * Create a {@code CharacterEncodingFilter} for the given encoding.
	 * @param encoding the encoding to apply
	 * @since 4.2.3
	 * @see #setEncoding
	 */
	public CharacterEncodingFilter(String encoding) {
		this(encoding, false);
	}

	/**
	 * Create a {@code CharacterEncodingFilter} for the given encoding.
	 * @param encoding the encoding to apply
	 * @param forceEncoding whether the specified encoding is supposed to
	 * override existing request and response encodings
	 * @since 4.2.3
	 * @see #setEncoding
	 * @see #setForceEncoding
	 */
	public CharacterEncodingFilter(String encoding, boolean forceEncoding) {
		this(encoding, forceEncoding, forceEncoding);
	}

	/**
	 * Create a {@code CharacterEncodingFilter} for the given encoding.
	 * @param encoding the encoding to apply
	 * @param forceRequestEncoding whether the specified encoding is supposed to
	 * override existing request encodings
	 * @param forceResponseEncoding whether the specified encoding is supposed to
	 * override existing response encodings
	 * @since 4.3
	 * @see #setEncoding
	 * @see #setForceRequestEncoding(boolean)
	 * @see #setForceResponseEncoding(boolean)
	 */
	public CharacterEncodingFilter(String encoding, boolean forceRequestEncoding, boolean forceResponseEncoding) {
		Assert.hasLength(encoding, "Encoding must not be empty");
		this.encoding = encoding;
		this.forceRequestEncoding = forceRequestEncoding;
		this.forceResponseEncoding = forceResponseEncoding;
	}


	/**
	 * Set the encoding to use for requests. This encoding will be passed into a
	 * {@link jakarta.servlet.http.HttpServletRequest#setCharacterEncoding} call.
	 * <p>Whether this encoding will override existing request encodings
	 * (and whether it will be applied as default response encoding as well)
	 * depends on the {@link #setForceEncoding "forceEncoding"} flag.
	 */
	public void setEncoding(@Nullable String encoding) {
		this.encoding = encoding;
	}

	/**
	 * Return the configured encoding for requests and/or responses.
	 * @since 4.3
	 */
	@Nullable
	public String getEncoding() {
		return this.encoding;
	}

	/**
	 * Set whether the configured {@link #setEncoding encoding} of this filter
	 * is supposed to override existing request and response encodings.
	 * <p>Default is "false", i.e. do not modify the encoding if
	 * {@link jakarta.servlet.http.HttpServletRequest#getCharacterEncoding()}
	 * returns a non-null value. Switch this to "true" to enforce the specified
	 * encoding in any case, applying it as default response encoding as well.
	 * <p>This is the equivalent to setting both {@link #setForceRequestEncoding(boolean)}
	 * and {@link #setForceResponseEncoding(boolean)}.
	 * @see #setForceRequestEncoding(boolean)
	 * @see #setForceResponseEncoding(boolean)
	 */
	public void setForceEncoding(boolean forceEncoding) {
		this.forceRequestEncoding = forceEncoding;
		this.forceResponseEncoding = forceEncoding;
	}

	/**
	 * Set whether the configured {@link #setEncoding encoding} of this filter
	 * is supposed to override existing request encodings.
	 * <p>Default is "false", i.e. do not modify the encoding if
	 * {@link jakarta.servlet.http.HttpServletRequest#getCharacterEncoding()}
	 * returns a non-null value. Switch this to "true" to enforce the specified
	 * encoding in any case.
	 * @since 4.3
	 */
	public void setForceRequestEncoding(boolean forceRequestEncoding) {
		this.forceRequestEncoding = forceRequestEncoding;
	}

	/**
	 * Return whether the encoding should be forced on requests.
	 * @since 4.3
	 */
	public boolean isForceRequestEncoding() {
		return this.forceRequestEncoding;
	}

	/**
	 * Set whether the configured {@link #setEncoding encoding} of this filter
	 * is supposed to override existing response encodings.
	 * <p>Default is "false", i.e. do not modify the encoding.
	 * Switch this to "true" to enforce the specified encoding
	 * for responses in any case.
	 * @since 4.3
	 */
	public void setForceResponseEncoding(boolean forceResponseEncoding) {
		this.forceResponseEncoding = forceResponseEncoding;
	}

	/**
	 * Return whether the encoding should be forced on responses.
	 * @since 4.3
	 */
	public boolean isForceResponseEncoding() {
		return this.forceResponseEncoding;
	}


	@Override
	protected void doFilterInternal(
			HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
			throws ServletException, IOException {

		String encoding = getEncoding();
		if (encoding != null) {
			if (isForceRequestEncoding() || request.getCharacterEncoding() == null) {
				request.setCharacterEncoding(encoding);
			}
			if (isForceResponseEncoding()) {
				response.setCharacterEncoding(encoding);
			}
		}
		filterChain.doFilter(request, response);
	}

}

```


最核心的方法是：    
```java
@Override
protected void doFilterInternal(
        HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
        throws ServletException, IOException {

    String encoding = getEncoding();
    if (encoding != null) {
        if (isForceRequestEncoding() || request.getCharacterEncoding() == null) {
            request.setCharacterEncoding(encoding);
        }
        if (isForceResponseEncoding()) {
            response.setCharacterEncoding(encoding);
        }
    }
    filterChain.doFilter(request, response);
}
```
分析以上核心方法得知该过滤器对请求和响应都设置了字符编码方式。
- **当强行使用请求字符编码方式为true时，或者请求对象的字符编码方式为null时，设置请求的字符编码方式为属性encoding的属性值**。
- **当强行使用响应字符编码方式为true时，设置响应的字符编码方式为属性encoding的属性值**。



根据以上代码，可以得出以下配置信息，在web.xml文件中对过滤器进行如下配置：
```xml
<!--字符编码过滤器-->
<filter>
    <filter-name>characterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name>
        <param-value>UTF-8</param-value>
    </init-param>
    <init-param>
        <param-name>forceRequestEncoding</param-name>
        <param-value>true</param-value>
    </init-param>
    <init-param>
        <param-name>forceResponseEncoding</param-name>
        <param-value>true</param-value>
    </init-param>
</filter>
<filter-mapping>
    <filter-name>characterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```




#### 自己编写过滤器来解决post乱码问题
和javaWeb中学的一样，写一个过滤器即可

自己写的过滤器如下图所示  
![](assets/08请求的中文乱码问题/file-20250805115011618.png)

在web.xml中配置该过滤器  
![](assets/08请求的中文乱码问题/file-20250805115150345.png)