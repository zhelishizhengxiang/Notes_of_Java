假设有这样一个请求：http://localhost:8080/springmvc/register?name=zhangsan&password=123&email=zhangsan@powernode.com
**在SpringMVC中应该如何获取请求提交的数据呢？**
**在SpringMVC中又应该如何获取请求头信息呢？**
**在SpringMVC中又应该如何获取客户端提交的Cookie数据呢？**

## 创建模块，添加依赖
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.powernode.springmvc</groupId>
    <artifactId>springmvc-003</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>war</packaging>

    <dependencies>
        <!--springmvc依赖-->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>6.1.4</version>
        </dependency>
        <!--logback依赖-->
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.5.3</version>
        </dependency>
        <!--servlet依赖-->
        <dependency>
            <groupId>jakarta.servlet</groupId>
            <artifactId>jakarta.servlet-api</artifactId>
            <version>6.0.0</version>
            <scope>provided</scope>
        </dependency>
        <!--thymeleaf和spring6整合的依赖-->
        <dependency>
            <groupId>org.thymeleaf</groupId>
            <artifactId>thymeleaf-spring6</artifactId>
            <version>3.1.2.RELEASE</version>
        </dependency>
    </dependencies>

    <properties>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

</project>
```


## 添加web支持
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710418588238-98865609-699f-4cb6-8ce4-d85a48da0469.png#averageHue=%23f4f6f9&clientId=u9d1e8f4e-33cf-4&from=paste&height=850&id=u181a21ca&originHeight=850&originWidth=1604&originalType=binary&ratio=1&rotation=0&showTitle=false&size=86035&status=done&style=none&taskId=u2634e762-bd7d-476a-a5d1-8d6f119b2cb&title=&width=1604)

## 编写web.xml文件
```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="https://jakarta.ee/xml/ns/jakartaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_6_0.xsd"
         version="6.0">

    <!--前端控制器-->
    <servlet>
        <servlet-name>springmvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!--通过初始化参数来指定springmvc配置文件的路径和名字。-->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:springmvc.xml</param-value>
        </init-param>
        <!--在服务器启动的时候初始化DispatcherServlet，提高第一次访问的效率-->
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>springmvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>

</web-app>
```


## 创建UserController
```java
package com.powernode.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

/**
 * ClassName: UserController
 * Description:
 * Datetime: 2024/3/14 20:05
 * Author: 老杜@动力节点
 * Version: 1.0
 */
@Controller
public class UserController {
    @RequestMapping("/")
    public String toRegisterPage(){
        return "register";
    }
}
```


## 编写springmvc.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

    <!--组件扫描-->
    <context:component-scan base-package="com.powernode.springmvc.controller"/>

    <!--视图解析器-->
    <bean id="thymeleafViewResolver" class="org.thymeleaf.spring6.view.ThymeleafViewResolver">
        <!--作用于视图渲染的过程中，可以设置视图渲染后输出时采用的编码字符集-->
        <property name="characterEncoding" value="UTF-8"/>
        <!--如果配置多个视图解析器，它来决定优先使用哪个视图解析器，它的值越小优先级越高-->
        <property name="order" value="1"/>
        <!--当 ThymeleafViewResolver 渲染模板时，会使用该模板引擎来解析、编译和渲染模板-->
        <property name="templateEngine">
            <bean class="org.thymeleaf.spring6.SpringTemplateEngine">
                <!--用于指定 Thymeleaf 模板引擎使用的模板解析器。模板解析器负责根据模板位置、模板资源名称、文件编码等信息，加载模板并对其进行解析-->
                <property name="templateResolver">
                    <bean class="org.thymeleaf.spring6.templateresolver.SpringResourceTemplateResolver">
                        <!--设置模板文件的位置（前缀）-->
                        <property name="prefix" value="/WEB-INF/templates/"/>
                        <!--设置模板文件后缀（后缀），Thymeleaf文件扩展名不一定是html，也可以是其他，例如txt，大部分都是html-->
                        <property name="suffix" value=".html"/>
                        <!--设置模板类型，例如：HTML,TEXT,JAVASCRIPT,CSS等-->
                        <property name="templateMode" value="HTML"/>
                        <!--用于模板文件在读取和解析过程中采用的编码字符集-->
                        <property name="characterEncoding" value="UTF-8"/>
                    </bean>
                </property>
            </bean>
        </property>
    </bean>

</beans>
```


## 编写register.html文件
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710418693211-64c3f53c-31a0-4ccd-9f2e-0023ef97afb4.png#averageHue=%23f0f3f8&clientId=u9d1e8f4e-33cf-4&from=paste&height=312&id=uaa19a950&originHeight=312&originWidth=325&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17530&status=done&style=none&taskId=u6af9fd77-6684-4bab-9e84-264271d8332&title=&width=325)
```xml
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>用户注册</title>
</head>
<body>
<h3>用户注册</h3>
<hr>
</body>
</html>
```


## 部署测试
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710418729572-558f5f1f-b30c-48f6-be0b-be0e58ce8af9.png#averageHue=%23fafaf9&clientId=u9d1e8f4e-33cf-4&from=paste&height=161&id=u9fd0ed57&originHeight=161&originWidth=431&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7113&status=done&style=none&taskId=u20f63d6b-9334-4b6f-8bf0-3e4c7ff66b8&title=&width=431)






# RequestHeader注解
该注解的作用是：将`请求头信息`映射到`方法的形参上`。
和RequestParam注解功能相似，RequestParam注解的作用：将`请求参数`映射到`方法的形参`上。
当然，对于RequestHeader注解来说，也有三个属性：value、required、defaultValue，和RequestParam一样，这里就不再赘述了。

测试：
```java
@PostMapping("/register")
public String register(User user, 
                       @RequestHeader(value="Referer", required = false, defaultValue = "") 
                       String referer){
    System.out.println(user);
    System.out.println(referer);
    return "success";
}
```

执行结果：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710472685320-fa79ddc4-04e0-4f8e-b97e-56f3f28ee60f.png#averageHue=%23f9f3f1&clientId=u9c5ec896-edd3-4&from=paste&height=100&id=u968684d7&originHeight=100&originWidth=1131&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21660&status=done&style=shadow&taskId=uabce8eab-3132-4c53-bf57-fed7ab1cb6b&title=&width=1131)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=GQgNy&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)
# CookieValue注解
该注解的作用：将`请求提交的Cookie数据`映射到`方法形参`上
同样是有三个属性：value、required、defaultValue

前端页面中编写发送cookie的代码：
```html
<script type="text/javascript">
    function sendCookie(){
        document.cookie = "id=123456789; expires=Thu, 18 Dec 2025 12:00:00 UTC; path=/";
        document.location = "/springmvc/register";
    }
</script>
<button onclick="sendCookie()">向服务器端发送Cookie</button>
```

后端UserController代码：
```java
    @GetMapping("/register")
    public String register(User user,
                           @RequestHeader(value="Referer", required = false, defaultValue = "")
                           String referer,
                           @CookieValue(value="id", required = false, defaultValue = "2222222222")
                           String id){
        System.out.println(user);
        System.out.println(referer);
        System.out.println(id);
        return "success";
    }
```

测试结果：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710473271244-7a95563a-fff4-458e-914f-25b314c78bd1.png#averageHue=%23fbf8f6&clientId=u9c5ec896-edd3-4&from=paste&height=128&id=ue186aba0&originHeight=128&originWidth=989&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21701&status=done&style=shadow&taskId=ub4dab47d-4e8a-43d9-a0af-7239f97f1e7&title=&width=989)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=ndH18&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)
# 请求的中文乱码问题
## get请求乱码
get请求数据在URI后面提交，这个乱码问题怎么解决呢？解决办法是找到 CATALINA_HOME/config/server.xml文件，找到其中配置端口号的标签<Connector>，在该标签中添加  URIEncoding="UTF-8"。但是对于高版本的Tomcat服务器来说，是不需要设置的，例如Tomcat10，Tomcat9，有如下的默认配置，在默认情况下URIEncoding使用的就是UTF-8的编码方式。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710480361252-0f3431f2-906f-41ea-b4b9-ac9dba2d926a.png#averageHue=%23c9dff1&clientId=u9c5ec896-edd3-4&from=paste&height=375&id=u56378d90&originHeight=375&originWidth=1127&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68507&status=done&style=shadow&taskId=u67ba8020-6dfc-447c-968e-2d58ec2d750&title=&width=1127)
但对于低版本的Tomcat服务器，例如：Tomcat8。URIEncoding的默认配置是ISO-8859-1，因此在Tomcat8中需要手动配置server.xml文件：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710480799719-41567287-3dcb-441b-853f-15114b8c2216.png#averageHue=%23eef4fb&clientId=u9c5ec896-edd3-4&from=paste&height=346&id=u82f7afb0&originHeight=346&originWidth=762&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41871&status=done&style=shadow&taskId=uef26f821-2f5a-4786-984a-9ca3b1bf9fe&title=&width=762)
配置如下：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710480903724-206fb06c-4cff-4ed0-a24b-83ceefb65d79.png#averageHue=%23f9f4f2&clientId=u9c5ec896-edd3-4&from=paste&height=292&id=u480fdc4d&originHeight=292&originWidth=451&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23728&status=done&style=shadow&taskId=ua46057d5-9b99-4e72-b0e9-cbc8655c3c4&title=&width=451)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710480932430-381979d9-289d-4c8a-abc7-653e824c8753.png#averageHue=%23fdfaf8&clientId=u9c5ec896-edd3-4&from=paste&height=148&id=u98600f2b&originHeight=148&originWidth=707&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15301&status=done&style=shadow&taskId=ue3b70f18-d7b5-44a4-a986-d1766fbada2&title=&width=707)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=Cf3EA&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

接下来，我们测试一下，在默认情况下，Tomcat10是否已经解决了get请求乱码问题：
```html
<form th:action="@{/register}" method="get">
    用户名：<input type="text" name="username"><br>
    密码：<input type="password" name="password"><br>
    性别：
        男 <input type="radio" name="sex" value="1">
        女 <input type="radio" name="sex" value="0">
        <br>
    爱好：
        抽烟 <input type="checkbox" name="hobby" value="smoke">
        喝酒 <input type="checkbox" name="hobby" value="drink">
        烫头 <input type="checkbox" name="hobby" value="perm">
        <br>
    简介：<textarea rows="10" cols="60" name="intro"></textarea><br>
    <input type="submit" value="注册">
</form>
```
注意，以上表单已经修改为get请求了。
```java
@GetMapping("/register")
public String register(User user){
    System.out.println(user);
    return "success";
}
```
测试结果：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710481129146-18d9e4e2-8385-423a-adc5-3d379323cbb7.png#averageHue=%23fbf9f9&clientId=u9c5ec896-edd3-4&from=paste&height=353&id=u7dd03e01&originHeight=353&originWidth=547&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11182&status=done&style=shadow&taskId=ucb980289-2641-4aee-a8da-39eb044013d&title=&width=547)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710481146376-640c0e7f-6872-453a-b3ea-b34b899bf16d.png#averageHue=%23d6b687&clientId=u9c5ec896-edd3-4&from=paste&height=212&id=u4695c042&originHeight=212&originWidth=1167&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18475&status=done&style=shadow&taskId=ucf68979f-2344-4438-9b8b-9395f5103fd&title=&width=1167)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710481162744-dba51e29-fadf-4d68-a79c-50f9fb3e951b.png#averageHue=%23f8f2ef&clientId=u9c5ec896-edd3-4&from=paste&height=84&id=ucc20b11b&originHeight=84&originWidth=1181&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23594&status=done&style=shadow&taskId=ue6a609ec-37e2-4ffa-a300-47e3e379179&title=&width=1181)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=gLGk1&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)
## post请求乱码
post请求是解决请求体的中文乱码问题。解决办法大家都知道：
```java
request.setCharacterEncoding("UTF-8");
```

同样，对于高版本的**Tomcat10**服务器来说，针对请求体中的字符编码也是配置好的，默认也是采用了UTF-8，中文乱码问题也解决了，在这个文件中配置的：apache-tomcat-10.1.19\conf\web.xml
配置内容如下：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710731491577-383b3f5b-046a-47c4-8da9-86b52ab1f535.png#averageHue=%23fcfcf9&clientId=uaa027169-bbba-4&from=paste&height=118&id=u554f4f5b&originHeight=118&originWidth=1038&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12763&status=done&style=shadow&taskId=ua54535d4-a1c1-4416-bd44-1caf5ba6a70&title=&width=1038)
通过以上配置可以看到，Tomcat10对请求和响应都设置了默认的字符编码方式为UTF-8
**一定要注意：Tomcat9以及之前的版本，以上的配置是没有的。**

我们来测试一下，针对Tomcat10来说，SpringMVC会不会有乱码问题：
```html
<form th:action="@{/register}" method="post">
    用户名：<input type="text" name="username"><br>
    密码：<input type="password" name="password"><br>
    性别：
        男 <input type="radio" name="sex" value="1">
        女 <input type="radio" name="sex" value="0">
        <br>
    爱好：
        抽烟 <input type="checkbox" name="hobby" value="smoke">
        喝酒 <input type="checkbox" name="hobby" value="drink">
        烫头 <input type="checkbox" name="hobby" value="perm">
        <br>
    简介：<textarea rows="10" cols="60" name="intro"></textarea><br>
    <input type="submit" value="注册">
</form>
```
注意：以上表单已经修改为post请求
```java
@PostMapping("/register")
public String register(User user, HttpServletRequest request) throws UnsupportedEncodingException {
    System.out.println(user);
    return "success";
}
```
测试结果：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710481669556-b01327ea-202b-42b7-8f65-5d0d5fabe764.png#averageHue=%23f8f8f7&clientId=u9c5ec896-edd3-4&from=paste&height=351&id=yzBYT&originHeight=351&originWidth=525&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11158&status=done&style=shadow&taskId=u16a83f4f-6aad-42f1-ba06-b4944844b67&title=&width=525)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=vbIkr&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710731963626-7c6e6d8c-a222-4588-b17d-5dafe2923abb.png#averageHue=%23d5b07e&clientId=uaa027169-bbba-4&from=paste&height=202&id=uefbb20b6&originHeight=202&originWidth=458&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12508&status=done&style=shadow&taskId=ue14d1f18-d66d-405b-a146-35421e45ce7&title=&width=458)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710731980833-96d1f7fe-aae4-48e9-b876-0b233834f563.png#averageHue=%23f7e8e5&clientId=uaa027169-bbba-4&from=paste&height=98&id=u38f2b40e&originHeight=98&originWidth=1158&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28986&status=done&style=shadow&taskId=u34c57d0d-18f0-42aa-95d9-39b68a6cd36&title=&width=1158)
通过测试可以看到在Tomcat10当中，默认SpringMVC，发送POST请求，是不会出现乱码问题的。

有可能很多同学使用的不是Tomcat10，如果不是Tomcat10，则会出现乱码问题，我们来模拟一下乱码的产生，将apache-tomcat-10.1.19\conf\web.xml文件中的UTF-8配置修改为ISO-8859-1：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710732413713-0f034192-e4d4-4c33-aeb3-169726468251.png#averageHue=%23fbfaf6&clientId=uaa027169-bbba-4&from=paste&height=100&id=u2e406be6&originHeight=100&originWidth=1076&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14164&status=done&style=shadow&taskId=u29422620-4508-4e2a-b9f9-55883186649&title=&width=1076)
**一定要重启Tomcat10**，新的配置才能生效，来测试一下是否存在乱码：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710732483068-b356942a-9183-4734-812d-041a151df48d.png#averageHue=%23f7f3ef&clientId=uaa027169-bbba-4&from=paste&height=107&id=u6f629e75&originHeight=107&originWidth=1261&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29572&status=done&style=shadow&taskId=uf4ea95b7-d40b-450f-8c09-94e4531b65a&title=&width=1261)

那么，在SpringMVC中如何解决请求体的中文乱码问题呢？当然，还是使用`request.setCharacterEncoding("UTF-8")`
使用它有一个前提条件，要想解决请求体乱码问题，以上代码必须在 `request.getParameter("username")`执行之前执行才有效。
也就是说以上代码如果放在Controller的相关方法中执行是无效的，因为Controller的方法在执行之前 DispatcherServlet已经调用了 `request.getParameter("username")`方法。因此在Controller方法中使用`request.setCharacterEncoding("UTF-8");`无效我们来测试一下：
```html
<form th:action="@{/register}" method="post">
    用户名：<input type="text" name="username"><br>
    密码：<input type="password" name="password"><br>
    性别：
        男 <input type="radio" name="sex" value="1">
        女 <input type="radio" name="sex" value="0">
        <br>
    爱好：
        抽烟 <input type="checkbox" name="hobby" value="smoke">
        喝酒 <input type="checkbox" name="hobby" value="drink">
        烫头 <input type="checkbox" name="hobby" value="perm">
        <br>
    简介：<textarea rows="10" cols="60" name="intro"></textarea><br>
    <input type="submit" value="注册">
</form>
```
注意：以上表单已经修改为post请求
```java
@PostMapping("/register")
public String register(User user, HttpServletRequest request) throws UnsupportedEncodingException {
    request.setCharacterEncoding("UTF-8");
    System.out.println(user);
    return "success";
}
```

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=hyAau&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

测试结果：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710481669556-b01327ea-202b-42b7-8f65-5d0d5fabe764.png#averageHue=%23f8f8f7&clientId=u9c5ec896-edd3-4&from=paste&height=351&id=uf9df1daa&originHeight=351&originWidth=525&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11158&status=done&style=shadow&taskId=u16a83f4f-6aad-42f1-ba06-b4944844b67&title=&width=525)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710732483068-b356942a-9183-4734-812d-041a151df48d.png#averageHue=%23f7f3ef&clientId=uaa027169-bbba-4&from=paste&height=107&id=prLSj&originHeight=107&originWidth=1261&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29572&status=done&style=shadow&taskId=uf4ea95b7-d40b-450f-8c09-94e4531b65a&title=&width=1261)
通过测试可以看到：在Controller当中调用`request.setCharacterEncoding("UTF-8")`是无法解决POST乱码问题的。

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=gS67k&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

那怎么办呢？怎么样才能在DispatcherServlet之前执行`request.setCharacterEncoding("UTF-8")`呢？没错，我相信大家想到了：过滤器Filter。过滤器Filter可以在Servlet执行之前执行。有同学又说了：监听器不行吗？不行。因为我们需要对每一次请求解决乱码，而监听器只在服务器启动阶段执行一次。因此这里解决每一次请求的乱码问题，应该使用过滤器Filter。并且，告诉大家一个好消息，SpringMVC已经将这个字符编码的过滤器提前写好了，我们直接配置好即可：`CharacterEncodingFilter`，我们一起看一下它的源码：
```java
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.web.filter;

import java.io.IOException;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Servlet Filter that allows one to specify a character encoding for requests.
 * This is useful because current browsers typically do not set a character
 * encoding even if specified in the HTML page or form.
 *
 * <p>This filter can either apply its encoding if the request does not already
 * specify an encoding, or enforce this filter's encoding in any case
 * ("forceEncoding"="true"). In the latter case, the encoding will also be
 * applied as default response encoding (although this will usually be overridden
 * by a full content type set in the view).
 *
 * @author Juergen Hoeller
 * @since 15.03.2004
 * @see #setEncoding
 * @see #setForceEncoding
 * @see jakarta.servlet.http.HttpServletRequest#setCharacterEncoding
 * @see jakarta.servlet.http.HttpServletResponse#setCharacterEncoding
 */
public class CharacterEncodingFilter extends OncePerRequestFilter {

	@Nullable
	private String encoding;

	private boolean forceRequestEncoding = false;

	private boolean forceResponseEncoding = false;


	/**
	 * Create a default {@code CharacterEncodingFilter},
	 * with the encoding to be set via {@link #setEncoding}.
	 * @see #setEncoding
	 */
	public CharacterEncodingFilter() {
	}

	/**
	 * Create a {@code CharacterEncodingFilter} for the given encoding.
	 * @param encoding the encoding to apply
	 * @since 4.2.3
	 * @see #setEncoding
	 */
	public CharacterEncodingFilter(String encoding) {
		this(encoding, false);
	}

	/**
	 * Create a {@code CharacterEncodingFilter} for the given encoding.
	 * @param encoding the encoding to apply
	 * @param forceEncoding whether the specified encoding is supposed to
	 * override existing request and response encodings
	 * @since 4.2.3
	 * @see #setEncoding
	 * @see #setForceEncoding
	 */
	public CharacterEncodingFilter(String encoding, boolean forceEncoding) {
		this(encoding, forceEncoding, forceEncoding);
	}

	/**
	 * Create a {@code CharacterEncodingFilter} for the given encoding.
	 * @param encoding the encoding to apply
	 * @param forceRequestEncoding whether the specified encoding is supposed to
	 * override existing request encodings
	 * @param forceResponseEncoding whether the specified encoding is supposed to
	 * override existing response encodings
	 * @since 4.3
	 * @see #setEncoding
	 * @see #setForceRequestEncoding(boolean)
	 * @see #setForceResponseEncoding(boolean)
	 */
	public CharacterEncodingFilter(String encoding, boolean forceRequestEncoding, boolean forceResponseEncoding) {
		Assert.hasLength(encoding, "Encoding must not be empty");
		this.encoding = encoding;
		this.forceRequestEncoding = forceRequestEncoding;
		this.forceResponseEncoding = forceResponseEncoding;
	}


	/**
	 * Set the encoding to use for requests. This encoding will be passed into a
	 * {@link jakarta.servlet.http.HttpServletRequest#setCharacterEncoding} call.
	 * <p>Whether this encoding will override existing request encodings
	 * (and whether it will be applied as default response encoding as well)
	 * depends on the {@link #setForceEncoding "forceEncoding"} flag.
	 */
	public void setEncoding(@Nullable String encoding) {
		this.encoding = encoding;
	}

	/**
	 * Return the configured encoding for requests and/or responses.
	 * @since 4.3
	 */
	@Nullable
	public String getEncoding() {
		return this.encoding;
	}

	/**
	 * Set whether the configured {@link #setEncoding encoding} of this filter
	 * is supposed to override existing request and response encodings.
	 * <p>Default is "false", i.e. do not modify the encoding if
	 * {@link jakarta.servlet.http.HttpServletRequest#getCharacterEncoding()}
	 * returns a non-null value. Switch this to "true" to enforce the specified
	 * encoding in any case, applying it as default response encoding as well.
	 * <p>This is the equivalent to setting both {@link #setForceRequestEncoding(boolean)}
	 * and {@link #setForceResponseEncoding(boolean)}.
	 * @see #setForceRequestEncoding(boolean)
	 * @see #setForceResponseEncoding(boolean)
	 */
	public void setForceEncoding(boolean forceEncoding) {
		this.forceRequestEncoding = forceEncoding;
		this.forceResponseEncoding = forceEncoding;
	}

	/**
	 * Set whether the configured {@link #setEncoding encoding} of this filter
	 * is supposed to override existing request encodings.
	 * <p>Default is "false", i.e. do not modify the encoding if
	 * {@link jakarta.servlet.http.HttpServletRequest#getCharacterEncoding()}
	 * returns a non-null value. Switch this to "true" to enforce the specified
	 * encoding in any case.
	 * @since 4.3
	 */
	public void setForceRequestEncoding(boolean forceRequestEncoding) {
		this.forceRequestEncoding = forceRequestEncoding;
	}

	/**
	 * Return whether the encoding should be forced on requests.
	 * @since 4.3
	 */
	public boolean isForceRequestEncoding() {
		return this.forceRequestEncoding;
	}

	/**
	 * Set whether the configured {@link #setEncoding encoding} of this filter
	 * is supposed to override existing response encodings.
	 * <p>Default is "false", i.e. do not modify the encoding.
	 * Switch this to "true" to enforce the specified encoding
	 * for responses in any case.
	 * @since 4.3
	 */
	public void setForceResponseEncoding(boolean forceResponseEncoding) {
		this.forceResponseEncoding = forceResponseEncoding;
	}

	/**
	 * Return whether the encoding should be forced on responses.
	 * @since 4.3
	 */
	public boolean isForceResponseEncoding() {
		return this.forceResponseEncoding;
	}


	@Override
	protected void doFilterInternal(
			HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
			throws ServletException, IOException {

		String encoding = getEncoding();
		if (encoding != null) {
			if (isForceRequestEncoding() || request.getCharacterEncoding() == null) {
				request.setCharacterEncoding(encoding);
			}
			if (isForceResponseEncoding()) {
				response.setCharacterEncoding(encoding);
			}
		}
		filterChain.doFilter(request, response);
	}

}

```

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=kGwQR&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

最核心的方法是：
```java
@Override
protected void doFilterInternal(
        HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
        throws ServletException, IOException {

    String encoding = getEncoding();
    if (encoding != null) {
        if (isForceRequestEncoding() || request.getCharacterEncoding() == null) {
            request.setCharacterEncoding(encoding);
        }
        if (isForceResponseEncoding()) {
            response.setCharacterEncoding(encoding);
        }
    }
    filterChain.doFilter(request, response);
}
```
分析以上核心方法得知该过滤器对请求和响应都设置了字符编码方式。

- 当`强行使用请求字符编码方式为true`时，或者`请求对象的字符编码方式为null`时，设置请求的字符编码方式。
- 当`强行使用响应字符编码方式为true`时，设置响应的字符编码方式。

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=uSjW6&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

根据以上代码，可以得出以下配置信息，在web.xml文件中对过滤器进行如下配置：
```xml
<!--字符编码过滤器-->
<filter>
    <filter-name>characterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name>
        <param-value>UTF-8</param-value>
    </init-param>
    <init-param>
        <param-name>forceRequestEncoding</param-name>
        <param-value>true</param-value>
    </init-param>
    <init-param>
        <param-name>forceResponseEncoding</param-name>
        <param-value>true</param-value>
    </init-param>
</filter>
<filter-mapping>
    <filter-name>characterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```


![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=VRThm&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

我们再来测试，重启Tomcat10，看看乱码是否能够解决？
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710733643651-29370350-6188-4ada-a8b0-99c6264f3b7a.png#averageHue=%23f6e7e3&clientId=uaa027169-bbba-4&from=paste&height=92&id=ubacc784a&originHeight=92&originWidth=1166&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28924&status=done&style=shadow&taskId=u02ff2728-92e6-43dd-90bc-33100c05bd5&title=&width=1166)

注意：针对于我们当前的Tomcat10的配置来说，它有默认的字符集ISO-8859-1，因此以下在web.xml文件中的配置是不能缺少的：
```xml
<init-param>
    <param-name>forceRequestEncoding</param-name>
    <param-value>true</param-value>
</init-param>
```
如果缺少它，仍然是会存在乱码问题的。自行测试一下！！！！


