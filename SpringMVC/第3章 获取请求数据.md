假设有这样一个请求：http://localhost:8080/springmvc/register?name=zhangsan&password=123&email=zhangsan@powernode.com
在SpringMVC中应该如何获取请求提交的数据呢？
在SpringMVC中又应该如何获取请求头信息呢？
在SpringMVC中又应该如何获取客户端提交的Cookie数据呢？

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=u48f9f116&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)
# 准备
## 创建模块，添加依赖
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.powernode.springmvc</groupId>
    <artifactId>springmvc-003</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>war</packaging>

    <dependencies>
        <!--springmvc依赖-->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>6.1.4</version>
        </dependency>
        <!--logback依赖-->
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.5.3</version>
        </dependency>
        <!--servlet依赖-->
        <dependency>
            <groupId>jakarta.servlet</groupId>
            <artifactId>jakarta.servlet-api</artifactId>
            <version>6.0.0</version>
            <scope>provided</scope>
        </dependency>
        <!--thymeleaf和spring6整合的依赖-->
        <dependency>
            <groupId>org.thymeleaf</groupId>
            <artifactId>thymeleaf-spring6</artifactId>
            <version>3.1.2.RELEASE</version>
        </dependency>
    </dependencies>

    <properties>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

</project>
```

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=Ij6D0&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)
## 添加web支持
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710418588238-98865609-699f-4cb6-8ce4-d85a48da0469.png#averageHue=%23f4f6f9&clientId=u9d1e8f4e-33cf-4&from=paste&height=850&id=u181a21ca&originHeight=850&originWidth=1604&originalType=binary&ratio=1&rotation=0&showTitle=false&size=86035&status=done&style=none&taskId=u2634e762-bd7d-476a-a5d1-8d6f119b2cb&title=&width=1604)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=ko5WQ&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)
## 编写web.xml文件
```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="https://jakarta.ee/xml/ns/jakartaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_6_0.xsd"
         version="6.0">

    <!--前端控制器-->
    <servlet>
        <servlet-name>springmvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!--通过初始化参数来指定springmvc配置文件的路径和名字。-->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:springmvc.xml</param-value>
        </init-param>
        <!--在服务器启动的时候初始化DispatcherServlet，提高第一次访问的效率-->
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>springmvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>

</web-app>
```

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=IMONP&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)
## 创建UserController
```java
package com.powernode.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

/**
 * ClassName: UserController
 * Description:
 * Datetime: 2024/3/14 20:05
 * Author: 老杜@动力节点
 * Version: 1.0
 */
@Controller
public class UserController {
    @RequestMapping("/")
    public String toRegisterPage(){
        return "register";
    }
}
```

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=FUCCo&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)
## 编写springmvc.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

    <!--组件扫描-->
    <context:component-scan base-package="com.powernode.springmvc.controller"/>

    <!--视图解析器-->
    <bean id="thymeleafViewResolver" class="org.thymeleaf.spring6.view.ThymeleafViewResolver">
        <!--作用于视图渲染的过程中，可以设置视图渲染后输出时采用的编码字符集-->
        <property name="characterEncoding" value="UTF-8"/>
        <!--如果配置多个视图解析器，它来决定优先使用哪个视图解析器，它的值越小优先级越高-->
        <property name="order" value="1"/>
        <!--当 ThymeleafViewResolver 渲染模板时，会使用该模板引擎来解析、编译和渲染模板-->
        <property name="templateEngine">
            <bean class="org.thymeleaf.spring6.SpringTemplateEngine">
                <!--用于指定 Thymeleaf 模板引擎使用的模板解析器。模板解析器负责根据模板位置、模板资源名称、文件编码等信息，加载模板并对其进行解析-->
                <property name="templateResolver">
                    <bean class="org.thymeleaf.spring6.templateresolver.SpringResourceTemplateResolver">
                        <!--设置模板文件的位置（前缀）-->
                        <property name="prefix" value="/WEB-INF/templates/"/>
                        <!--设置模板文件后缀（后缀），Thymeleaf文件扩展名不一定是html，也可以是其他，例如txt，大部分都是html-->
                        <property name="suffix" value=".html"/>
                        <!--设置模板类型，例如：HTML,TEXT,JAVASCRIPT,CSS等-->
                        <property name="templateMode" value="HTML"/>
                        <!--用于模板文件在读取和解析过程中采用的编码字符集-->
                        <property name="characterEncoding" value="UTF-8"/>
                    </bean>
                </property>
            </bean>
        </property>
    </bean>

</beans>
```

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=yF1as&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)
## 编写register.html文件
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710418693211-64c3f53c-31a0-4ccd-9f2e-0023ef97afb4.png#averageHue=%23f0f3f8&clientId=u9d1e8f4e-33cf-4&from=paste&height=312&id=uaa19a950&originHeight=312&originWidth=325&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17530&status=done&style=none&taskId=u6af9fd77-6684-4bab-9e84-264271d8332&title=&width=325)
```xml
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>用户注册</title>
</head>
<body>
<h3>用户注册</h3>
<hr>
</body>
</html>
```

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=qqotS&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)
## 部署测试
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710418729572-558f5f1f-b30c-48f6-be0b-be0e58ce8af9.png#averageHue=%23fafaf9&clientId=u9d1e8f4e-33cf-4&from=paste&height=161&id=u9fd0ed57&originHeight=161&originWidth=431&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7113&status=done&style=none&taskId=u20f63d6b-9334-4b6f-8bf0-3e4c7ff66b8&title=&width=431)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=vBWEF&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)
# 使用原生的Servlet API进行获取
原生的Servlet API指的是：HttpServletRequest
在SpringMVC当中，一个Controller类中的方法参数上如果有HttpServletRequest，SpringMVC会自动将`**当前请求对象**`传递给这个参数，因此我们可以通过这个参数来获取请求提交的数据。测试一下。

在 register.html 中准备一个注册的表单：
```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>用户注册</title>
</head>
<body>
<h3>用户注册</h3>
<hr>
<form th:action="@{/register}" method="post">
    用户名：<input type="text" name="username"><br>
    密码：<input type="password" name="password"><br>
    性别：
        男 <input type="radio" name="sex" value="1">
        女 <input type="radio" name="sex" value="0">
        <br>
    爱好：
        抽烟 <input type="checkbox" name="hobby" value="smoke">
        喝酒 <input type="checkbox" name="hobby" value="drink">
        烫头 <input type="checkbox" name="hobby" value="perm">
        <br>
    简介：<textarea rows="10" cols="60" name="intro"></textarea><br>
    <input type="submit" value="注册">
</form>
</body>
</html>
```
先测试这个页面是否可以正常打开，是否可以正常提交数据：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710419419412-530f021a-4b19-43de-bac8-800866cfe619.png#averageHue=%23fbfafa&clientId=u9d1e8f4e-33cf-4&from=paste&height=448&id=u513b4a69&originHeight=448&originWidth=528&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16298&status=done&style=none&taskId=ua1ab7921-0cf4-4da0-8951-30e90d9579c&title=&width=528)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=NhtNT&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

点击注册：F12的方式查看是否提交了数据：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710419495559-af90ea42-1002-4cab-8e38-c455b3b0a16d.png#averageHue=%23eac989&clientId=u9d1e8f4e-33cf-4&from=paste&height=106&id=u8fe6a988&originHeight=106&originWidth=714&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8446&status=done&style=none&taskId=u1e08d80d-c03f-4c2a-afdc-342241e7725&title=&width=714)
通过测试得知：可以正常提交数据。

接下来在控制器添加一个方法来处理这个注册的请求：
```java
@PostMapping(value="/register")
public String register(HttpServletRequest request){
    // 通过当前请求对象获取提交的数据
    String username = request.getParameter("username");
    String password = request.getParameter("password");
    String sex = request.getParameter("sex");
    String[] hobbies = request.getParameterValues("hobby");
    String intro = request.getParameter("intro");
    System.out.println(username + "," + password + "," + sex + "," + Arrays.toString(hobbies) + "," + intro);
    return "success";
}
```

提供视图页面：
```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>注册成功</title>
</head>
<body>
<h1>注册成功</h1>
</body>
</html>
```

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=ksBfh&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

测试：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710419827530-70740ef1-28a3-4766-9825-6d0cb5ebbf4a.png#averageHue=%23fafaf9&clientId=u9d1e8f4e-33cf-4&from=paste&height=361&id=ufbf91ed1&originHeight=361&originWidth=559&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11349&status=done&style=shadow&taskId=u8c5d516a-57fd-4c32-9b95-54bd42ad933&title=&width=559)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710419792573-b4d36148-dff4-45f6-ab97-e6de4e74a362.png#averageHue=%23f8f8f7&clientId=u9d1e8f4e-33cf-4&from=paste&height=186&id=u9190ef01&originHeight=186&originWidth=485&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9784&status=done&style=shadow&taskId=udb2f3c31-74ad-428b-adb6-434939d6e31&title=&width=485)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710419813547-5bb0218a-f11c-4438-982c-fc06964e7d45.png#averageHue=%23f7f4f0&clientId=u9d1e8f4e-33cf-4&from=paste&height=102&id=ud56d10fb&originHeight=102&originWidth=644&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19165&status=done&style=shadow&taskId=ufe093b32-8c7e-421c-9d97-c24aab5cb22&title=&width=644)

**这样通过Servlet原生的API获取到提交的数据。但是这种方式不建议使用，因为方法的参数依赖Servlet原生API，Controller的测试将不能单独测试，必须依赖WEB服务器才能测试。另外，换句话说，如果在SpringMVC中使用了原生的Servlet，你为什么还要用SpringMVC框架呢！！！！！**

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=eXieF&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)
# 使用RequestParam注解标注
## RequestParam注解的基本使用
RequestParam注解作用：将`请求参数`与方法上的`形参`映射。
```java
@PostMapping(value = "/register")
public String register(
        @RequestParam(value="username")
        String a,
        @RequestParam(value="password")
        String b,
        @RequestParam(value="sex")
        String c,
        @RequestParam(value="hobby")
        String[] d,
        @RequestParam(name="intro")
        String e) {
    System.out.println(a);
    System.out.println(b);
    System.out.println(c);
    System.out.println(Arrays.toString(d));
    System.out.println(e);
    return "success";
}
```

注意：对于@RequestParam注解来说，属性有value和name，这两个属性的作用相同，都是用来指定提交数据的name。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710428008416-73b3a547-46ab-47bb-922c-b3d090e0cfc9.png#averageHue=%23fdfbf8&clientId=u9d1e8f4e-33cf-4&from=paste&height=331&id=uaf3c3ba7&originHeight=331&originWidth=494&originalType=binary&ratio=1&rotation=0&showTitle=false&size=30298&status=done&style=shadow&taskId=u950651dd-684e-4de9-af50-2e721a82b8c&title=&width=494)
例如：发送请求时提交的数据是：name1=value1&name2=value2，则这个注解应该这样写：@RequestParam(value="name1")、@RequestParam(value="name2")

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=cQKAp&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

启动服务器测试：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710427890838-fe12392a-6fdf-4c94-8660-1bbee1f84a74.png#averageHue=%23fbfafa&clientId=u9d1e8f4e-33cf-4&from=paste&height=349&id=uc43a1942&originHeight=349&originWidth=544&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10924&status=done&style=shadow&taskId=u3fff6ffb-1196-4367-a348-00d141223a2&title=&width=544)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710427902078-fb8c772f-deae-49bc-93ec-0022ab4c8cd8.png#averageHue=%23f7f6f5&clientId=u9d1e8f4e-33cf-4&from=paste&height=163&id=u8a0409d9&originHeight=163&originWidth=455&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9552&status=done&style=shadow&taskId=u6e3d7af3-91cf-43bd-8905-38220eec21c&title=&width=455)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710427916293-aa47a26a-2d15-4b1b-ac6a-ada398655150.png#averageHue=%23fbf9f8&clientId=u9d1e8f4e-33cf-4&from=paste&height=209&id=u31439636&originHeight=209&originWidth=299&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12043&status=done&style=shadow&taskId=u24f9cf65-fb28-40b7-9084-cfef922a2d8&title=&width=299)

一定要注意： @RequestParam(value="name2") 中value一定不要写错，写错就会出现以下问题：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710428081389-9ac88bba-c37c-4fb8-9b9d-f7a9091b97ab.png#averageHue=%23fcfaf8&clientId=u9d1e8f4e-33cf-4&from=paste&height=604&id=ua16f46af&originHeight=604&originWidth=608&originalType=binary&ratio=1&rotation=0&showTitle=false&size=76072&status=done&style=shadow&taskId=ub5f0221a-83b2-445d-8aa1-d0c787f1d54&title=&width=608)
测试结果：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710428139767-d3888c35-e2f8-407f-accb-f744a7098148.png#averageHue=%23e7c692&clientId=u9d1e8f4e-33cf-4&from=paste&height=272&id=u1fdff3b9&originHeight=272&originWidth=741&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24103&status=done&style=none&taskId=u5eb32a33-98fe-4768-b1e9-1fdb9c1c61d&title=&width=741)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=O1kwB&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)
## RequestParam注解的required属性
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710465027479-caeb1d78-c92d-4fca-b9fa-80e6bcf06c7a.png#averageHue=%23fdfcf7&clientId=u9c5ec896-edd3-4&from=paste&height=181&id=u05ce0a11&originHeight=181&originWidth=670&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23639&status=done&style=shadow&taskId=uf614fe67-8ccc-4c8a-b773-840e46ac4f0&title=&width=670)
required属性用来设置该方法参数是否为必须的。
默认情况下，这个参数为 `true`，表示方法参数是必需的。如果请求中缺少对应的参数，则会抛出异常。
可以将其设置为`false`，false表示不是必须的，如果请求中缺少对应的参数，则方法的参数为null。

测试，修改register方法，如下：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710468078605-3c6a2dd2-e9c4-4450-9712-02f11b5543d3.png#averageHue=%23fcfaf9&clientId=u9c5ec896-edd3-4&from=paste&height=660&id=ue64914c9&originHeight=660&originWidth=610&originalType=binary&ratio=1&rotation=0&showTitle=false&size=83984&status=done&style=shadow&taskId=u2f988380-d51d-48ec-aec3-9d4be9fbe42&title=&width=610)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=kGVdF&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

添加了一个 age 形参，没有指定 required 属性时，默认是true，表示必需的，但前端表单中没有年龄age，我们来看报错信息：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710468194109-56b8df42-2110-4b2b-9e73-064884f2e04b.png#averageHue=%23e8c792&clientId=u9c5ec896-edd3-4&from=paste&height=231&id=u1a3fb4dc&originHeight=231&originWidth=807&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18905&status=done&style=shadow&taskId=u4ccbff44-68a6-48f0-89b3-b7c2243d422&title=&width=807)
错误信息告诉我们：参数age是必需的。没有提供这个请求参数，HTTP状态码 400

如果将 required 属性设置为 false。则该参数则不是必须的，如果请求参数仍然未提供时，我们来看结果：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710468402437-7395c6e2-6ab4-4bdc-a66e-cb82811be4e4.png#averageHue=%23fcf9f7&clientId=u9c5ec896-edd3-4&from=paste&height=692&id=u3168e498&originHeight=692&originWidth=685&originalType=binary&ratio=1&rotation=0&showTitle=false&size=92366&status=done&style=shadow&taskId=u8b6cd101-ae46-4d74-a6f8-d4d11007361&title=&width=685)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=TooD3&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710468358266-82e27b39-b24a-4aca-902e-9a69c5630ca7.png#averageHue=%23f7f7f6&clientId=u9c5ec896-edd3-4&from=paste&height=158&id=u0b40f7d7&originHeight=158&originWidth=488&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9575&status=done&style=shadow&taskId=uf88cd954-2db8-4f8e-9c25-590db9f20f9&title=&width=488)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710468442095-a0aa03e0-390e-440c-b9db-61139b8098cb.png#averageHue=%23fcf9f8&clientId=u9c5ec896-edd3-4&from=paste&height=194&id=uf8a54914&originHeight=194&originWidth=290&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7036&status=done&style=shadow&taskId=uc3022386-a167-46b2-8eb2-b3614e9a495&title=&width=290)
通过测试得知，如果一个参数被设置为`不是必需的`，当没有提交对应的请求参数时，形参默认值null。
当然，如果请求参数中提供了age，则age为真实提交的数据：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710469986610-0f8a53d3-5e70-4127-a102-909bd6b75a46.png#averageHue=%23f8f6f3&clientId=u9c5ec896-edd3-4&from=paste&height=510&id=ue4678651&originHeight=510&originWidth=779&originalType=binary&ratio=1&rotation=0&showTitle=false&size=83260&status=done&style=shadow&taskId=ufa33ce4b-0c36-46b9-9ea7-a4dffaa27c2&title=&width=779)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=IakKY&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710470042986-374bf055-aa7e-40d1-ae62-666d4b477ff9.png#averageHue=%23f9f8f8&clientId=u9c5ec896-edd3-4&from=paste&height=408&id=u447c8a81&originHeight=408&originWidth=586&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12406&status=done&style=shadow&taskId=u833a75a2-f685-4a14-a01e-2d0fcdd47ca&title=&width=586)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710470056000-452b7435-23c0-4c3f-a1d0-e4b4b933a802.png#averageHue=%23f6f6f5&clientId=u9c5ec896-edd3-4&from=paste&height=159&id=uc12c6f79&originHeight=159&originWidth=438&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9528&status=done&style=shadow&taskId=ue4d2c2c4-25e6-420a-8501-7821e8f70d3&title=&width=438)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710470068447-179bdbdc-7281-4db9-96ae-8c120f826898.png#averageHue=%23fcf9f8&clientId=u9c5ec896-edd3-4&from=paste&height=209&id=udaf54757&originHeight=209&originWidth=305&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9297&status=done&style=shadow&taskId=uc84010f3-4c31-40de-b8db-87c5f1b43df&title=&width=305)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=tMvDX&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

## RequestParam注解的defaultValue属性
defaultValue属性用来设置形参的默认值，当`没有提供对应的请求参数`或者`请求参数的值是空字符串""`的时候，方法的形参会采用默认值。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710470373422-d7c95422-71b8-4662-a99b-913343b8c59e.png#averageHue=%23fdfafa&clientId=u9c5ec896-edd3-4&from=paste&height=687&id=u2e8cc75d&originHeight=687&originWidth=1069&originalType=binary&ratio=1&rotation=0&showTitle=false&size=99557&status=done&style=shadow&taskId=u4933e1a0-3f95-40cc-bf17-61982515665&title=&width=1069)

当前端页面没有提交email的时候：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710470456573-54784174-401f-4fde-a7c3-9e3f88414d88.png#averageHue=%23f9f8f8&clientId=u9c5ec896-edd3-4&from=paste&height=359&id=ubffcf159&originHeight=359&originWidth=539&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10964&status=done&style=shadow&taskId=ud63d7f89-c02c-435e-820b-95db25ff1cb&title=&width=539)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=ELVlZ&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710470470975-d91804e7-a1ad-465f-a9dc-ed57e560d146.png#averageHue=%23f7f6f5&clientId=u9c5ec896-edd3-4&from=paste&height=160&id=u799975dc&originHeight=160&originWidth=464&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9631&status=done&style=shadow&taskId=uec3b5f22-29cb-4cd5-bd06-fceaa967784&title=&width=464)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710470482292-3a68329a-02e6-4a41-b3ae-f3ac1cb9635d.png#averageHue=%23fcf7f6&clientId=u9c5ec896-edd3-4&from=paste&height=184&id=uc47cf34c&originHeight=184&originWidth=444&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9583&status=done&style=shadow&taskId=u6f72afa7-730c-4a05-8932-6a45b438432&title=&width=444)

当前端页面提交的email是空字符串的时候：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710470529370-873dcc0f-40eb-4348-ac4b-82abf1d921f9.png#averageHue=%23f8f6f3&clientId=u9c5ec896-edd3-4&from=paste&height=495&id=u44487366&originHeight=495&originWidth=817&originalType=binary&ratio=1&rotation=0&showTitle=false&size=83349&status=done&style=shadow&taskId=uf787e9d6-7a63-4e16-9ed1-d9af22106b6&title=&width=817)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=m3ZBu&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710470563357-648e4929-5b70-4e25-a364-3905c89da147.png#averageHue=%23f9f7f7&clientId=u9c5ec896-edd3-4&from=paste&height=390&id=ub92f2ca0&originHeight=390&originWidth=562&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11893&status=done&style=shadow&taskId=u421d8e1e-4c85-4232-ba03-c723fc67522&title=&width=562)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710470573342-6a3b4497-74a9-44e0-a15b-add971551d64.png#averageHue=%23f7f7f6&clientId=u9c5ec896-edd3-4&from=paste&height=165&id=u5fb5dcde&originHeight=165&originWidth=477&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9628&status=done&style=shadow&taskId=u35f3d887-77a5-4135-bf1b-45090841453&title=&width=477)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710470582878-a1d3fc60-f4fc-4f6c-95db-0cd924fa7f75.png#averageHue=%23fcf5f5&clientId=u9c5ec896-edd3-4&from=paste&height=202&id=u295200cd&originHeight=202&originWidth=339&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9879&status=done&style=shadow&taskId=ub5a7b2cb-2380-47f8-bf28-701d5ad9152&title=&width=339)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=Nqh8r&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

当前端提交的email不是空字符串的时候：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710470628085-cb06b835-2098-4047-973f-5f572b6a09c0.png#averageHue=%23faf8f8&clientId=u9c5ec896-edd3-4&from=paste&height=390&id=u7cc385df&originHeight=390&originWidth=563&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13943&status=done&style=shadow&taskId=ue43fe266-9d34-4c26-9abd-11a160a8e04&title=&width=563)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710470635669-d5c193c2-f62a-44a9-881f-066e96cc4059.png#averageHue=%23f7f6f5&clientId=u9c5ec896-edd3-4&from=paste&height=164&id=ufe1c8d5c&originHeight=164&originWidth=446&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9560&status=done&style=shadow&taskId=u8b9b58d6-aab9-47f5-bbc6-8fa24adf09b&title=&width=446)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710470647079-313b64ca-4a54-4581-8dc6-11f039e70477.png#averageHue=%23fcf6f5&clientId=u9c5ec896-edd3-4&from=paste&height=197&id=u9f7a0b6f&originHeight=197&originWidth=324&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9549&status=done&style=shadow&taskId=u79314bf9-c735-45b4-a893-133f9cc0a8a&title=&width=324)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=CTnSw&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

# 依靠控制器方法上的形参名来接收
@RequestParam 这个注解是可以省略的，如果方法形参的名字和提交数据时的name相同，则 @RequestParam 可以省略。

但有一个前提：如果你采用的是Spring6+版本，你需要在pom.xml文件中指定编译参数'-parameter'，配置如下：
```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.12.1</version>
            <configuration>
                <source>21</source>
                <target>21</target>
                <compilerArgs>
                    <arg>-parameters</arg>
                </compilerArgs>
            </configuration>
        </plugin>
    </plugins>
</build>
```
**注意：如果你使用的是Spring5的版本，以上的配置是不需要的。**

Controller中的方法只需要这样写：**形参的名字必须和提交的数据的name一致！！！！！**
```java
@PostMapping(value="/register")
public String register(String username, String password, String sex, String[] hobby, String intro){
    System.out.println(username + "," + password + "," + sex + "," + Arrays.toString(hobby) + "," + intro);
    return "success";
}
```
测试结果：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710420392728-d9818422-a468-492b-ad80-ec87e4e8c39e.png#averageHue=%23f8f8f8&clientId=u9d1e8f4e-33cf-4&from=paste&height=362&id=uf1b977b9&originHeight=362&originWidth=524&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10966&status=done&style=shadow&taskId=ud5eaa772-ca3f-432b-808a-73776954539&title=&width=524)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710428543288-58b926eb-7646-465d-8ed1-3346d5c79214.png#averageHue=%23f7f6f5&clientId=u9d1e8f4e-33cf-4&from=paste&height=164&id=u1463a254&originHeight=164&originWidth=444&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9582&status=done&style=shadow&taskId=uc1cdd835-1af2-4f3d-8c2d-249f21c4f3b&title=&width=444)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710428556289-28ba3126-1783-4381-9fb1-2cb0cc82150d.png#averageHue=%23f8f5f2&clientId=u9d1e8f4e-33cf-4&from=paste&height=117&id=u75c30bd7&originHeight=117&originWidth=469&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15557&status=done&style=shadow&taskId=u82336644-b7b3-456a-b264-edddeb7698e&title=&width=469)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=S5EcE&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

如果形参名和提交的数据的name不一致时：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710428636791-b1c4eb79-ce31-4ecf-9ee5-4db8e6ffb0d6.png#averageHue=%23fcfaf5&clientId=u9d1e8f4e-33cf-4&from=paste&height=176&id=u3d867463&originHeight=176&originWidth=1252&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28696&status=done&style=shadow&taskId=ud66bc37e-8921-4188-ab1c-067d9a17b15&title=&width=1252)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710428682813-4c2440c7-0500-4d02-a66a-7a3852ebd981.png#averageHue=%23f5f0ec&clientId=u9d1e8f4e-33cf-4&from=paste&height=110&id=u4de014af&originHeight=110&originWidth=465&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18573&status=done&style=shadow&taskId=u9ac4874e-0c41-4ddb-a7e4-d138a86216d&title=&width=465)

另外，还有一点，对于提交的hobby数据，也可以采用String来接收，不一定使用数组方式：
```java
@PostMapping(value="/register")
public String register(String username, String password, String sex, String hobby, String intro){
    System.out.println(username + "," + password + "," + sex + "," + hobby + "," + intro);
    return "success";
}
```
测试结果：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710428821480-9f9f3a69-3697-4965-b127-e304fb9aa524.png#averageHue=%23f7eae6&clientId=u9d1e8f4e-33cf-4&from=paste&height=103&id=ucc4b49ab&originHeight=103&originWidth=472&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15860&status=done&style=shadow&taskId=ubd00fc1c-1706-4955-badd-cad618495f9&title=&width=472)
根据输出结果可以看到多个hobby是采用“,”进行连接的。

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=XFOMJ&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)
# 使用POJO类/JavaBean接收请求参数
以上方式大家可以看到，当提交的数据非常多时，方法的形参个数会非常多，这不是很好的设计。在SpringMVC中也可以使用POJO类/JavaBean来接收请求参数。不过有一个非常重要的要求：`POJO类的属性名`必须和`请求参数的参数名`保持一致。提供以下的JavaBean：
```java
package com.powernode.springmvc.pojo;

import java.util.Arrays;

/**
 * ClassName: User
 * Description:
 * Datetime: 2024/3/15 10:51
 * Author: 老杜@动力节点
 * Version: 1.0
 */
public class User {
    private Long id;
    private String username;
    private String password;
    private String sex;
    private String[] hobby;
    private String intro;

    public User() {
    }

    public User(Long id, String username, String password, String sex, String[] hobby, String intro) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.sex = sex;
        this.hobby = hobby;
        this.intro = intro;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public String[] getHobby() {
        return hobby;
    }

    public void setHobby(String[] hobby) {
        this.hobby = hobby;
    }

    public String getIntro() {
        return intro;
    }

    public void setIntro(String intro) {
        this.intro = intro;
    }

    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", username='" + username + '\'' +
                ", password='" + password + '\'' +
                ", sex='" + sex + '\'' +
                ", hobby=" + Arrays.toString(hobby) +
                ", intro='" + intro + '\'' +
                '}';
    }
}

```

在控制器方法的形参位置上使用javabean来接收请求参数：
```java
@PostMapping("/register")
public String register(User user){
    System.out.println(user);
    return "success";
}
```

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=XMtkj&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

执行结果：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710471338770-502eefb8-15b7-4632-9d07-37b1fa60a539.png#averageHue=%23fbfafa&clientId=u9c5ec896-edd3-4&from=paste&height=353&id=u67c745a5&originHeight=353&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10870&status=done&style=shadow&taskId=uc3623ddc-d1c6-4630-903b-7c9ea45c67c&title=&width=554)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710471328104-0ef741e8-70d3-4294-a559-165ffee8a821.png#averageHue=%23f8f7f7&clientId=u9c5ec896-edd3-4&from=paste&height=177&id=uaf53d3c9&originHeight=177&originWidth=474&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9721&status=done&style=shadow&taskId=udaf52420-4bdc-4236-a0ed-cb12b2edfe5&title=&width=474)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710471357753-31d5fe77-a5bf-470c-a5d0-ce777859188b.png#averageHue=%23f7eae7&clientId=u9c5ec896-edd3-4&from=paste&height=107&id=u9b0fe2d3&originHeight=107&originWidth=1097&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27074&status=done&style=shadow&taskId=u741d104a-6492-4b30-b596-e60b081fae3&title=&width=1097)

**底层的实现原理：反射机制。先获取请求参数的名字，因为请求参数的名字就是JavaBean的属性名，通过这种方式给对应的属性赋值**。

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=A6UpN&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

我们来测试一下：当JavaBean的属性名和请求参数的参数名不一致时，会出现什么问题？（注意：**getter和setter的方法名不修改，只修改属性名**）
```java
package com.powernode.springmvc.pojo;

import java.util.Arrays;

/**
 * ClassName: User
 * Description:
 * Datetime: 2024/3/15 10:51
 * Author: 老杜@动力节点
 * Version: 1.0
 */
public class User {
    private Long id;
    private String uname;
    private String upwd;
    private String usex;
    private String[] uhobby;
    private String uintro;

    public User() {
    }

    public User(Long id, String username, String password, String sex, String[] hobby, String intro) {
        this.id = id;
        this.uname = username;
        this.upwd = password;
        this.usex = sex;
        this.uhobby = hobby;
        this.uintro = intro;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getUsername() {
        return uname;
    }

    public void setUsername(String username) {
        this.uname = username;
    }

    public String getPassword() {
        return upwd;
    }

    public void setPassword(String password) {
        this.upwd = password;
    }

    public String getSex() {
        return usex;
    }

    public void setSex(String sex) {
        this.usex = sex;
    }

    public String[] getHobby() {
        return uhobby;
    }

    public void setHobby(String[] hobby) {
        this.uhobby = hobby;
    }

    public String getIntro() {
        return uintro;
    }

    public void setIntro(String intro) {
        this.uintro = intro;
    }

    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", username='" + uname + '\'' +
                ", password='" + upwd + '\'' +
                ", sex='" + usex + '\'' +
                ", hobby=" + Arrays.toString(uhobby) +
                ", intro='" + uintro + '\'' +
                '}';
    }
}

```

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=eXwPl&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

测试结果：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710471749061-322c5c24-45e5-40b4-95f0-3732508150b7.png#averageHue=%23f8f8f8&clientId=u9c5ec896-edd3-4&from=paste&height=363&id=ud9e62fc3&originHeight=363&originWidth=530&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11045&status=done&style=shadow&taskId=u9744a328-d8bb-4f6f-bfdc-89c41559642&title=&width=530)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710471758221-ea101ba1-8586-472c-9adc-e44729d1bac4.png#averageHue=%23f7f6f5&clientId=u9c5ec896-edd3-4&from=paste&height=154&id=u4074f891&originHeight=154&originWidth=478&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9571&status=done&style=shadow&taskId=uc18498a4-e874-467d-bb78-f69754d1f59&title=&width=478)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710471772183-af36c134-1f73-4cb4-afc6-4a6a827aacbd.png#averageHue=%23f7e5e2&clientId=u9c5ec896-edd3-4&from=paste&height=74&id=u0d56b9d1&originHeight=74&originWidth=1139&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18899&status=done&style=shadow&taskId=u25c77c23-8970-479e-ad63-ef845d09e00&title=&width=1139)
通过测试，我们得知：`请求参数名`可以和`JavaBean的属性名`不一致。

我们继续将其中一个属性的setter和getter方法名修改一下：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710471908862-89d1b430-cff1-43e2-9678-49017f49d663.png#averageHue=%23fdf9f9&clientId=u9c5ec896-edd3-4&from=paste&height=288&id=u86492b81&originHeight=288&originWidth=455&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22276&status=done&style=shadow&taskId=u326d4035-e801-4f1b-82a0-011bb90fee2&title=&width=455)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=bwWOv&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

再次测试：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710471941379-7da74eee-7b34-4dae-8589-98c0cf0a4d04.png#averageHue=%23f9f8f8&clientId=u9c5ec896-edd3-4&from=paste&height=364&id=u284e64cc&originHeight=364&originWidth=575&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11192&status=done&style=shadow&taskId=uf1d524de-4be1-4784-809e-ba148b477ae&title=&width=575)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710471949916-1049b6e4-df85-44f0-ba78-d2fe556f4fb9.png#averageHue=%23f6f5f4&clientId=u9c5ec896-edd3-4&from=paste&height=152&id=u7ee086b3&originHeight=152&originWidth=448&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9510&status=done&style=shadow&taskId=u0af2e626-0dd0-4f28-a0e4-4044fd0ddc1&title=&width=448)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710471961917-33f50796-7f73-4d40-a0ef-2befe83d5ebf.png#averageHue=%23f9f4f2&clientId=u9c5ec896-edd3-4&from=paste&height=85&id=u358b10f2&originHeight=85&originWidth=1179&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18263&status=done&style=shadow&taskId=u2c283f3a-2641-4ce3-9e71-3e36969abc4&title=&width=1179)

**通过测试可以看到：username属性没有赋上值。可见请求参数是否可以赋值到JavaBean对应的属性上，不是取决于属性名，而是setter方法名**。

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=FFqAC&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)
# RequestHeader注解
该注解的作用是：将`请求头信息`映射到`方法的形参上`。
和RequestParam注解功能相似，RequestParam注解的作用：将`请求参数`映射到`方法的形参`上。
当然，对于RequestHeader注解来说，也有三个属性：value、required、defaultValue，和RequestParam一样，这里就不再赘述了。

测试：
```java
@PostMapping("/register")
public String register(User user, 
                       @RequestHeader(value="Referer", required = false, defaultValue = "") 
                       String referer){
    System.out.println(user);
    System.out.println(referer);
    return "success";
}
```

执行结果：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710472685320-fa79ddc4-04e0-4f8e-b97e-56f3f28ee60f.png#averageHue=%23f9f3f1&clientId=u9c5ec896-edd3-4&from=paste&height=100&id=u968684d7&originHeight=100&originWidth=1131&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21660&status=done&style=shadow&taskId=uabce8eab-3132-4c53-bf57-fed7ab1cb6b&title=&width=1131)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=GQgNy&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)
# CookieValue注解
该注解的作用：将`请求提交的Cookie数据`映射到`方法形参`上
同样是有三个属性：value、required、defaultValue

前端页面中编写发送cookie的代码：
```html
<script type="text/javascript">
    function sendCookie(){
        document.cookie = "id=123456789; expires=Thu, 18 Dec 2025 12:00:00 UTC; path=/";
        document.location = "/springmvc/register";
    }
</script>
<button onclick="sendCookie()">向服务器端发送Cookie</button>
```

后端UserController代码：
```java
    @GetMapping("/register")
    public String register(User user,
                           @RequestHeader(value="Referer", required = false, defaultValue = "")
                           String referer,
                           @CookieValue(value="id", required = false, defaultValue = "2222222222")
                           String id){
        System.out.println(user);
        System.out.println(referer);
        System.out.println(id);
        return "success";
    }
```

测试结果：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710473271244-7a95563a-fff4-458e-914f-25b314c78bd1.png#averageHue=%23fbf8f6&clientId=u9c5ec896-edd3-4&from=paste&height=128&id=ue186aba0&originHeight=128&originWidth=989&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21701&status=done&style=shadow&taskId=ub4dab47d-4e8a-43d9-a0af-7239f97f1e7&title=&width=989)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=ndH18&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)
# 请求的中文乱码问题
## get请求乱码
get请求数据在URI后面提交，这个乱码问题怎么解决呢？解决办法是找到 CATALINA_HOME/config/server.xml文件，找到其中配置端口号的标签<Connector>，在该标签中添加  URIEncoding="UTF-8"。但是对于高版本的Tomcat服务器来说，是不需要设置的，例如Tomcat10，Tomcat9，有如下的默认配置，在默认情况下URIEncoding使用的就是UTF-8的编码方式。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710480361252-0f3431f2-906f-41ea-b4b9-ac9dba2d926a.png#averageHue=%23c9dff1&clientId=u9c5ec896-edd3-4&from=paste&height=375&id=u56378d90&originHeight=375&originWidth=1127&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68507&status=done&style=shadow&taskId=u67ba8020-6dfc-447c-968e-2d58ec2d750&title=&width=1127)
但对于低版本的Tomcat服务器，例如：Tomcat8。URIEncoding的默认配置是ISO-8859-1，因此在Tomcat8中需要手动配置server.xml文件：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710480799719-41567287-3dcb-441b-853f-15114b8c2216.png#averageHue=%23eef4fb&clientId=u9c5ec896-edd3-4&from=paste&height=346&id=u82f7afb0&originHeight=346&originWidth=762&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41871&status=done&style=shadow&taskId=uef26f821-2f5a-4786-984a-9ca3b1bf9fe&title=&width=762)
配置如下：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710480903724-206fb06c-4cff-4ed0-a24b-83ceefb65d79.png#averageHue=%23f9f4f2&clientId=u9c5ec896-edd3-4&from=paste&height=292&id=u480fdc4d&originHeight=292&originWidth=451&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23728&status=done&style=shadow&taskId=ua46057d5-9b99-4e72-b0e9-cbc8655c3c4&title=&width=451)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710480932430-381979d9-289d-4c8a-abc7-653e824c8753.png#averageHue=%23fdfaf8&clientId=u9c5ec896-edd3-4&from=paste&height=148&id=u98600f2b&originHeight=148&originWidth=707&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15301&status=done&style=shadow&taskId=ue3b70f18-d7b5-44a4-a986-d1766fbada2&title=&width=707)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=Cf3EA&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

接下来，我们测试一下，在默认情况下，Tomcat10是否已经解决了get请求乱码问题：
```html
<form th:action="@{/register}" method="get">
    用户名：<input type="text" name="username"><br>
    密码：<input type="password" name="password"><br>
    性别：
        男 <input type="radio" name="sex" value="1">
        女 <input type="radio" name="sex" value="0">
        <br>
    爱好：
        抽烟 <input type="checkbox" name="hobby" value="smoke">
        喝酒 <input type="checkbox" name="hobby" value="drink">
        烫头 <input type="checkbox" name="hobby" value="perm">
        <br>
    简介：<textarea rows="10" cols="60" name="intro"></textarea><br>
    <input type="submit" value="注册">
</form>
```
注意，以上表单已经修改为get请求了。
```java
@GetMapping("/register")
public String register(User user){
    System.out.println(user);
    return "success";
}
```
测试结果：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710481129146-18d9e4e2-8385-423a-adc5-3d379323cbb7.png#averageHue=%23fbf9f9&clientId=u9c5ec896-edd3-4&from=paste&height=353&id=u7dd03e01&originHeight=353&originWidth=547&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11182&status=done&style=shadow&taskId=ucb980289-2641-4aee-a8da-39eb044013d&title=&width=547)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710481146376-640c0e7f-6872-453a-b3ea-b34b899bf16d.png#averageHue=%23d6b687&clientId=u9c5ec896-edd3-4&from=paste&height=212&id=u4695c042&originHeight=212&originWidth=1167&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18475&status=done&style=shadow&taskId=ucf68979f-2344-4438-9b8b-9395f5103fd&title=&width=1167)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710481162744-dba51e29-fadf-4d68-a79c-50f9fb3e951b.png#averageHue=%23f8f2ef&clientId=u9c5ec896-edd3-4&from=paste&height=84&id=ucc20b11b&originHeight=84&originWidth=1181&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23594&status=done&style=shadow&taskId=ue6a609ec-37e2-4ffa-a300-47e3e379179&title=&width=1181)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=gLGk1&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)
## post请求乱码
post请求是解决请求体的中文乱码问题。解决办法大家都知道：
```java
request.setCharacterEncoding("UTF-8");
```

同样，对于高版本的**Tomcat10**服务器来说，针对请求体中的字符编码也是配置好的，默认也是采用了UTF-8，中文乱码问题也解决了，在这个文件中配置的：apache-tomcat-10.1.19\conf\web.xml
配置内容如下：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710731491577-383b3f5b-046a-47c4-8da9-86b52ab1f535.png#averageHue=%23fcfcf9&clientId=uaa027169-bbba-4&from=paste&height=118&id=u554f4f5b&originHeight=118&originWidth=1038&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12763&status=done&style=shadow&taskId=ua54535d4-a1c1-4416-bd44-1caf5ba6a70&title=&width=1038)
通过以上配置可以看到，Tomcat10对请求和响应都设置了默认的字符编码方式为UTF-8
**一定要注意：Tomcat9以及之前的版本，以上的配置是没有的。**

我们来测试一下，针对Tomcat10来说，SpringMVC会不会有乱码问题：
```html
<form th:action="@{/register}" method="post">
    用户名：<input type="text" name="username"><br>
    密码：<input type="password" name="password"><br>
    性别：
        男 <input type="radio" name="sex" value="1">
        女 <input type="radio" name="sex" value="0">
        <br>
    爱好：
        抽烟 <input type="checkbox" name="hobby" value="smoke">
        喝酒 <input type="checkbox" name="hobby" value="drink">
        烫头 <input type="checkbox" name="hobby" value="perm">
        <br>
    简介：<textarea rows="10" cols="60" name="intro"></textarea><br>
    <input type="submit" value="注册">
</form>
```
注意：以上表单已经修改为post请求
```java
@PostMapping("/register")
public String register(User user, HttpServletRequest request) throws UnsupportedEncodingException {
    System.out.println(user);
    return "success";
}
```
测试结果：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710481669556-b01327ea-202b-42b7-8f65-5d0d5fabe764.png#averageHue=%23f8f8f7&clientId=u9c5ec896-edd3-4&from=paste&height=351&id=yzBYT&originHeight=351&originWidth=525&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11158&status=done&style=shadow&taskId=u16a83f4f-6aad-42f1-ba06-b4944844b67&title=&width=525)

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=vbIkr&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710731963626-7c6e6d8c-a222-4588-b17d-5dafe2923abb.png#averageHue=%23d5b07e&clientId=uaa027169-bbba-4&from=paste&height=202&id=uefbb20b6&originHeight=202&originWidth=458&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12508&status=done&style=shadow&taskId=ue14d1f18-d66d-405b-a146-35421e45ce7&title=&width=458)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710731980833-96d1f7fe-aae4-48e9-b876-0b233834f563.png#averageHue=%23f7e8e5&clientId=uaa027169-bbba-4&from=paste&height=98&id=u38f2b40e&originHeight=98&originWidth=1158&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28986&status=done&style=shadow&taskId=u34c57d0d-18f0-42aa-95d9-39b68a6cd36&title=&width=1158)
通过测试可以看到在Tomcat10当中，默认SpringMVC，发送POST请求，是不会出现乱码问题的。

有可能很多同学使用的不是Tomcat10，如果不是Tomcat10，则会出现乱码问题，我们来模拟一下乱码的产生，将apache-tomcat-10.1.19\conf\web.xml文件中的UTF-8配置修改为ISO-8859-1：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710732413713-0f034192-e4d4-4c33-aeb3-169726468251.png#averageHue=%23fbfaf6&clientId=uaa027169-bbba-4&from=paste&height=100&id=u2e406be6&originHeight=100&originWidth=1076&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14164&status=done&style=shadow&taskId=u29422620-4508-4e2a-b9f9-55883186649&title=&width=1076)
**一定要重启Tomcat10**，新的配置才能生效，来测试一下是否存在乱码：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710732483068-b356942a-9183-4734-812d-041a151df48d.png#averageHue=%23f7f3ef&clientId=uaa027169-bbba-4&from=paste&height=107&id=u6f629e75&originHeight=107&originWidth=1261&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29572&status=done&style=shadow&taskId=uf4ea95b7-d40b-450f-8c09-94e4531b65a&title=&width=1261)

那么，在SpringMVC中如何解决请求体的中文乱码问题呢？当然，还是使用`request.setCharacterEncoding("UTF-8")`
使用它有一个前提条件，要想解决请求体乱码问题，以上代码必须在 `request.getParameter("username")`执行之前执行才有效。
也就是说以上代码如果放在Controller的相关方法中执行是无效的，因为Controller的方法在执行之前 DispatcherServlet已经调用了 `request.getParameter("username")`方法。因此在Controller方法中使用`request.setCharacterEncoding("UTF-8");`无效我们来测试一下：
```html
<form th:action="@{/register}" method="post">
    用户名：<input type="text" name="username"><br>
    密码：<input type="password" name="password"><br>
    性别：
        男 <input type="radio" name="sex" value="1">
        女 <input type="radio" name="sex" value="0">
        <br>
    爱好：
        抽烟 <input type="checkbox" name="hobby" value="smoke">
        喝酒 <input type="checkbox" name="hobby" value="drink">
        烫头 <input type="checkbox" name="hobby" value="perm">
        <br>
    简介：<textarea rows="10" cols="60" name="intro"></textarea><br>
    <input type="submit" value="注册">
</form>
```
注意：以上表单已经修改为post请求
```java
@PostMapping("/register")
public String register(User user, HttpServletRequest request) throws UnsupportedEncodingException {
    request.setCharacterEncoding("UTF-8");
    System.out.println(user);
    return "success";
}
```

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=hyAau&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

测试结果：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710481669556-b01327ea-202b-42b7-8f65-5d0d5fabe764.png#averageHue=%23f8f8f7&clientId=u9c5ec896-edd3-4&from=paste&height=351&id=uf9df1daa&originHeight=351&originWidth=525&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11158&status=done&style=shadow&taskId=u16a83f4f-6aad-42f1-ba06-b4944844b67&title=&width=525)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710732483068-b356942a-9183-4734-812d-041a151df48d.png#averageHue=%23f7f3ef&clientId=uaa027169-bbba-4&from=paste&height=107&id=prLSj&originHeight=107&originWidth=1261&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29572&status=done&style=shadow&taskId=uf4ea95b7-d40b-450f-8c09-94e4531b65a&title=&width=1261)
通过测试可以看到：在Controller当中调用`request.setCharacterEncoding("UTF-8")`是无法解决POST乱码问题的。

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=gS67k&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

那怎么办呢？怎么样才能在DispatcherServlet之前执行`request.setCharacterEncoding("UTF-8")`呢？没错，我相信大家想到了：过滤器Filter。过滤器Filter可以在Servlet执行之前执行。有同学又说了：监听器不行吗？不行。因为我们需要对每一次请求解决乱码，而监听器只在服务器启动阶段执行一次。因此这里解决每一次请求的乱码问题，应该使用过滤器Filter。并且，告诉大家一个好消息，SpringMVC已经将这个字符编码的过滤器提前写好了，我们直接配置好即可：`CharacterEncodingFilter`，我们一起看一下它的源码：
```java
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.web.filter;

import java.io.IOException;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Servlet Filter that allows one to specify a character encoding for requests.
 * This is useful because current browsers typically do not set a character
 * encoding even if specified in the HTML page or form.
 *
 * <p>This filter can either apply its encoding if the request does not already
 * specify an encoding, or enforce this filter's encoding in any case
 * ("forceEncoding"="true"). In the latter case, the encoding will also be
 * applied as default response encoding (although this will usually be overridden
 * by a full content type set in the view).
 *
 * @author Juergen Hoeller
 * @since 15.03.2004
 * @see #setEncoding
 * @see #setForceEncoding
 * @see jakarta.servlet.http.HttpServletRequest#setCharacterEncoding
 * @see jakarta.servlet.http.HttpServletResponse#setCharacterEncoding
 */
public class CharacterEncodingFilter extends OncePerRequestFilter {

	@Nullable
	private String encoding;

	private boolean forceRequestEncoding = false;

	private boolean forceResponseEncoding = false;


	/**
	 * Create a default {@code CharacterEncodingFilter},
	 * with the encoding to be set via {@link #setEncoding}.
	 * @see #setEncoding
	 */
	public CharacterEncodingFilter() {
	}

	/**
	 * Create a {@code CharacterEncodingFilter} for the given encoding.
	 * @param encoding the encoding to apply
	 * @since 4.2.3
	 * @see #setEncoding
	 */
	public CharacterEncodingFilter(String encoding) {
		this(encoding, false);
	}

	/**
	 * Create a {@code CharacterEncodingFilter} for the given encoding.
	 * @param encoding the encoding to apply
	 * @param forceEncoding whether the specified encoding is supposed to
	 * override existing request and response encodings
	 * @since 4.2.3
	 * @see #setEncoding
	 * @see #setForceEncoding
	 */
	public CharacterEncodingFilter(String encoding, boolean forceEncoding) {
		this(encoding, forceEncoding, forceEncoding);
	}

	/**
	 * Create a {@code CharacterEncodingFilter} for the given encoding.
	 * @param encoding the encoding to apply
	 * @param forceRequestEncoding whether the specified encoding is supposed to
	 * override existing request encodings
	 * @param forceResponseEncoding whether the specified encoding is supposed to
	 * override existing response encodings
	 * @since 4.3
	 * @see #setEncoding
	 * @see #setForceRequestEncoding(boolean)
	 * @see #setForceResponseEncoding(boolean)
	 */
	public CharacterEncodingFilter(String encoding, boolean forceRequestEncoding, boolean forceResponseEncoding) {
		Assert.hasLength(encoding, "Encoding must not be empty");
		this.encoding = encoding;
		this.forceRequestEncoding = forceRequestEncoding;
		this.forceResponseEncoding = forceResponseEncoding;
	}


	/**
	 * Set the encoding to use for requests. This encoding will be passed into a
	 * {@link jakarta.servlet.http.HttpServletRequest#setCharacterEncoding} call.
	 * <p>Whether this encoding will override existing request encodings
	 * (and whether it will be applied as default response encoding as well)
	 * depends on the {@link #setForceEncoding "forceEncoding"} flag.
	 */
	public void setEncoding(@Nullable String encoding) {
		this.encoding = encoding;
	}

	/**
	 * Return the configured encoding for requests and/or responses.
	 * @since 4.3
	 */
	@Nullable
	public String getEncoding() {
		return this.encoding;
	}

	/**
	 * Set whether the configured {@link #setEncoding encoding} of this filter
	 * is supposed to override existing request and response encodings.
	 * <p>Default is "false", i.e. do not modify the encoding if
	 * {@link jakarta.servlet.http.HttpServletRequest#getCharacterEncoding()}
	 * returns a non-null value. Switch this to "true" to enforce the specified
	 * encoding in any case, applying it as default response encoding as well.
	 * <p>This is the equivalent to setting both {@link #setForceRequestEncoding(boolean)}
	 * and {@link #setForceResponseEncoding(boolean)}.
	 * @see #setForceRequestEncoding(boolean)
	 * @see #setForceResponseEncoding(boolean)
	 */
	public void setForceEncoding(boolean forceEncoding) {
		this.forceRequestEncoding = forceEncoding;
		this.forceResponseEncoding = forceEncoding;
	}

	/**
	 * Set whether the configured {@link #setEncoding encoding} of this filter
	 * is supposed to override existing request encodings.
	 * <p>Default is "false", i.e. do not modify the encoding if
	 * {@link jakarta.servlet.http.HttpServletRequest#getCharacterEncoding()}
	 * returns a non-null value. Switch this to "true" to enforce the specified
	 * encoding in any case.
	 * @since 4.3
	 */
	public void setForceRequestEncoding(boolean forceRequestEncoding) {
		this.forceRequestEncoding = forceRequestEncoding;
	}

	/**
	 * Return whether the encoding should be forced on requests.
	 * @since 4.3
	 */
	public boolean isForceRequestEncoding() {
		return this.forceRequestEncoding;
	}

	/**
	 * Set whether the configured {@link #setEncoding encoding} of this filter
	 * is supposed to override existing response encodings.
	 * <p>Default is "false", i.e. do not modify the encoding.
	 * Switch this to "true" to enforce the specified encoding
	 * for responses in any case.
	 * @since 4.3
	 */
	public void setForceResponseEncoding(boolean forceResponseEncoding) {
		this.forceResponseEncoding = forceResponseEncoding;
	}

	/**
	 * Return whether the encoding should be forced on responses.
	 * @since 4.3
	 */
	public boolean isForceResponseEncoding() {
		return this.forceResponseEncoding;
	}


	@Override
	protected void doFilterInternal(
			HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
			throws ServletException, IOException {

		String encoding = getEncoding();
		if (encoding != null) {
			if (isForceRequestEncoding() || request.getCharacterEncoding() == null) {
				request.setCharacterEncoding(encoding);
			}
			if (isForceResponseEncoding()) {
				response.setCharacterEncoding(encoding);
			}
		}
		filterChain.doFilter(request, response);
	}

}

```

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=kGwQR&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

最核心的方法是：
```java
@Override
protected void doFilterInternal(
        HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
        throws ServletException, IOException {

    String encoding = getEncoding();
    if (encoding != null) {
        if (isForceRequestEncoding() || request.getCharacterEncoding() == null) {
            request.setCharacterEncoding(encoding);
        }
        if (isForceResponseEncoding()) {
            response.setCharacterEncoding(encoding);
        }
    }
    filterChain.doFilter(request, response);
}
```
分析以上核心方法得知该过滤器对请求和响应都设置了字符编码方式。

- 当`强行使用请求字符编码方式为true`时，或者`请求对象的字符编码方式为null`时，设置请求的字符编码方式。
- 当`强行使用响应字符编码方式为true`时，设置响应的字符编码方式。

![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=uSjW6&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

根据以上代码，可以得出以下配置信息，在web.xml文件中对过滤器进行如下配置：
```xml
<!--字符编码过滤器-->
<filter>
    <filter-name>characterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name>
        <param-value>UTF-8</param-value>
    </init-param>
    <init-param>
        <param-name>forceRequestEncoding</param-name>
        <param-value>true</param-value>
    </init-param>
    <init-param>
        <param-name>forceResponseEncoding</param-name>
        <param-value>true</param-value>
    </init-param>
</filter>
<filter-mapping>
    <filter-name>characterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```


![标头.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&clientId=uc5a67c34-8a0d-4&from=paste&height=78&id=VRThm&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23158&status=done&style=shadow&taskId=u98709943-fd0b-4e51-821c-a3fc0aef219&title=&width=1400)

我们再来测试，重启Tomcat10，看看乱码是否能够解决？
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1710733643651-29370350-6188-4ada-a8b0-99c6264f3b7a.png#averageHue=%23f6e7e3&clientId=uaa027169-bbba-4&from=paste&height=92&id=ubacc784a&originHeight=92&originWidth=1166&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28924&status=done&style=shadow&taskId=u02ff2728-92e6-43dd-90bc-33100c05bd5&title=&width=1166)

注意：针对于我们当前的Tomcat10的配置来说，它有默认的字符集ISO-8859-1，因此以下在web.xml文件中的配置是不能缺少的：
```xml
<init-param>
    <param-name>forceRequestEncoding</param-name>
    <param-value>true</param-value>
</init-param>
```
如果缺少它，仍然是会存在乱码问题的。自行测试一下！！！！


