# 一、@ResponseBody注解
* **实际开发中，大部分请求都是ajax请求，也就是局部的更新，所以只需要响应数据即可或者前端向后端传递数据即可,而无需返回视图。而局部的更新的ajax请求就算要携带数据通常也都是通过json作为数据的载体，将信息写在请求体当中。所以Controller在处理的时候通常是要对请求体进行操作**。
* **注意：在JavaWeb中- 表单参数是键值对格式（如 `name=张三&age=20`），`request.getParameter()` 能直接按键解析。JSON 是结构化字符串（如 `{"name":"张三","age":20}`），需要专用的 JSON 解析工具（如 Jackson、Gson 等）将其转换为 Java 对象或 Map 才能方便地获取数据**


* **@ResponseBody是专门处理ajax请求，代替原生的Servlet API的**
* **当处理器方法上加有@ResponseBody时，处理器方法return返回的字符串就不再是视图名称，而是代表返回的内容是直接作为响应体中的内容进行响应。具体为下面的处理方式**：

1. **如果返回的是一个字符串，那么底层而是直接将返回结果采用字符串的形式响应给浏览器。因为其底层采用的消息转换器为： StringHttpMessageConverter。底层实现原理实际上代替的就是**
```java
PrintWriter out = response.getWriter();  
out.print("hello ajax, my name is Spring MVC!");**
```
2. **如果返回的是一个java对象，例如user。那么springmvc框架会自动将user对象转换成json格式的字符串响应给浏览器。当然，你必须要在pom.xml文件中引入一个可以处理json的依赖，例如jackson。其底层启用的就是 MappingJackson2HttpMessageConverter 消息转换器**

注：其实这个消息转换器`MappingJackson2HttpMessageConverter`本质上只是比`StringHttpMessageConverter`多了一个json字符串的转换，其他的还是一样
## 1.StringHttpMessageConverter
上面的AJAX案例，Controller的代码可以修改为：
```java
package com.powernode.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class HelloController {

    @RequestMapping(value = "/hello")
    @ResponseBody
    public String hello(){
        // 由于你使用了 @ResponseBody 注解
        // 以下的return语句返回的字符串则不再是“逻辑视图名”了
        // 而是作为响应协议的响应体进行响应。
        return "hello";
    }
}
```
* 最核心需要理解的位置是：return "hello";
* 这里的"hello"不是逻辑视图名了，而是作为响应体的内容进行响应。直接输出到浏览器客户端。
* 以上程序中使用的消息转换器是：**StringHttpMessageConverter**，为什么会启用这个消息转换器呢？因为你添加`@ResponseBody`这个注解。


通常AJAX请求需要服务器给返回一段JSON格式的字符串，可以返回JSON格式的字符串吗？当然可以，代码如下：
```java
package com.powernode.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class HelloController {

    @RequestMapping(value = "/hello")
    @ResponseBody
    public String hello(){
        return "{\"username\":\"zhangsan\",\"password\":\"1234\"}";
    }
}
```



测试：    
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1711013196948-31c55e31-5868-40e9-b75c-f84810ef3056.png#averageHue=%23f6f5f4&clientId=u2fdcbe87-8e74-4&from=paste&height=259&id=uf76c1469&originHeight=259&originWidth=821&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18587&status=done&style=shadow&taskId=ue9eade83-dcb9-47f8-94b8-a06c4d7e62b&title=&width=821)
这是完全可以的，此时底层使用的消息转换器还是：**StringHttpMessageConverter**

**那如果在程序中是一个POJO对象，怎么将POJO对象以JSON格式的字符串响应给浏览器呢？两种方式**：  
- **第一种方式：自己写代码将POJO对象转换成JSON格式的字符串，用上面的方式直接return即可**。
- **第二种方式：启用`MappingJackson2HttpMessageConverter`消息转换器。**


## 2.MappingJackson2HttpMessageConverter
**启用MappingJackson2HttpMessageConverter消息转换器的步骤如下**：

第一步：引入jackson依赖，可以将java对象转换为json格式字符串
```xml
<dependency>
  <groupId>com.fasterxml.jackson.core</groupId>
  <artifactId>jackson-databind</artifactId>
  <version>2.17.0</version>
</dependency>
```

**第二步：开启注解驱动**

这一步非常关键，开启注解驱动后，在HandlerAdapter中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter
```xml
<mvc:annotation-driven/>
```



第三步：准备一个POJO
```java
package com.powernode.springmvc.bean;

public class User {
    private String username;
    private String password;

    public User() {
    }

    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
```



第四步：控制器方法使用 @ResponseBody 注解标注(非常重要），控制器方法返回这个POJO对象
```java
package com.powernode.springmvc.controller;

import com.powernode.springmvc.bean.User;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class HelloController {

    @RequestMapping(value = "/hello")
    @ResponseBody
    public User hello(){
        User user = new User("zhangsan", "22222");
        return user;
    }
}

```


测试：    
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1711014082618-8a46beab-d498-4d67-abad-662e07d5871f.png#averageHue=%23f6f6f5&clientId=u2fdcbe87-8e74-4&from=paste&height=284&id=u0c94604d&originHeight=284&originWidth=843&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18664&status=done&style=shadow&taskId=udce9980a-01af-435b-bfea-254d65dea11&title=&width=843)

* 以上代码底层启用的就是 MappingJackson2HttpMessageConverter 消息转换器。
他的功能很强大，可以将POJO对象转换成JSON格式的字符串，响应给前端。
其实这个消息转换器`MappingJackson2HttpMessageConverter`本质上只是比`StringHttpMessageConverter`多了一个json字符串的转换，其他的还是一样。

# 二、@RestController注解

* 因为我们现代的开发方式都是基于AJAX方式的，因此 @ResponseBody 注解非常重要，很常用。为了方便，**Spring MVC中提供了一个注解 @RestController。这一个注解代表了：@Controller + @ResponseBody。**
* **@RestController 标注在类上即可。被它标注的Controller中所有的方法上都会自动标注 @ResponseBody**

```java
package com.powernode.springmvc.controller;

import com.powernode.springmvc.bean.User;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {

    @RequestMapping(value = "/hello")
    public User hello(){
        User user = new User("zhangsan", "22222");
        return user;
    }
}

```

测试：  
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1711014419291-3b5e131c-f81f-4054-9a03-295323dee8d4.png#averageHue=%23f6f5f4&clientId=u2fdcbe87-8e74-4&from=paste&height=266&id=u52ca289a&originHeight=266&originWidth=827&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18568&status=done&style=shadow&taskId=u0282b26a-291c-42d5-84fc-fdf0a178a7e&title=&width=827)

# 三、@RequestBody注解

* 当请求方式为post时，请求体就会携带请求参数
* **这个注解的基本作用是直接将请求体传递给Java程序，在Java程序中可以直接使用一个String类型的变量接收这个请求体的内容。底层使用的HTTP消息转换器是：FormHttpMessageConverter**。
* **该注解还有一个重要作用：如果前端请求体当中提交的数据是JSON格式，那么 @RequestBody 可以将提交的JSON格式的字符串转换成java对象。那么就继续可以使用pojo类来接收请求体的内容（JSON字符串无法直接通过getParameter()来获取参数并直接赋给pojo类，所以必须要使用该注解）**。
	1. **注意@RequestBody标注在处理器方法的形参上，也就是说形参只要准备一个user对象就行了**。
	2. **以上前端请求体提交JSON格式的字符串，那么后端直接将json格式字符串转换成java对象，这里使用的消息转换器是：MappingJackson2HttpMessageConverter。注意：同样需要使用jackson的依赖。  
* **当使用这个注解的时候：这个注解只能出现在方法的参数上。**
## 1.FormHttpMessageConverter
在没有使用这个注解的时候：
```java
@RequestMapping("/save")
public String save(User user){
    // 执行保存的业务逻辑
    userDao.save(user);
    // 保存成功跳转到成功页面
    return "success";
}
```
当请求体提交的数据是：
```
username=zhangsan&password=1234&email=zhangsan@powernode.com
```
* **那么Spring MVC会自动使用 `FormHttpMessageConverter`消息转换器，将请求体转换成user对象**。


当使用该注解时：
```java
@RequestMapping("/save")
public String save(@RequestBody String requestBodyStr){
    System.out.println("请求体：" + requestBodyStr);
    return "success";
}
```
**Spring MVC仍然会使用 `FormHttpMessageConverter`消息转换器，但是将请求体直接以字符串形式传递给 requestBodyStr 变量**。

测试输出结果：      
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1711022270055-a1599817-6c63-4d06-bfe6-52c10bcdf3ef.png#averageHue=%23f5e3de&clientId=u2fdcbe87-8e74-4&from=paste&height=81&id=u5823cf53&originHeight=81&originWidth=697&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20811&status=done&style=shadow&taskId=u5406b47e-fcaf-4cf1-b0ac-bc21d9dff70&title=&width=697)

## 2.MappingJackson2HttpMessageConverter
* **另外，如果在请求体中提交的是一个JSON格式的字符串，这个JSON字符串传递给Spring MVC之后，能不能将JSON字符串转换成POJO对象呢？答案是可以的。**
* **此时必须使用@RequestBody 注解来完成 。并且底层使用的消息转换器是：`MappingJackson2HttpMessageConverter`。实现步骤如下**：

- 第一步：引入jackson依赖
- 第二步：开启注解驱动
- 第三步：创建POJO类，将POJO类作为控制器方法的参数，并使用 @RequestBody 注解标注该参数
```java
@RequestMapping("/send")
@ResponseBody
public String send(@RequestBody User user){
    System.out.println(user);
    System.out.println(user.getUsername());
    System.out.println(user.getPassword());
    return "success";
}
```

- 第四步：在请求体中提交json格式的数据
```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>首页</title>
    <script th:src="@{/static/js/vue3.4.21.js}"></script>
    <script th:src="@{/static/js/axios.min.js}"></script>
</head>
<body>

<div id="app">
    <button @click="sendJSON">通过POST请求发送JSON给服务器</button>
    <h1>{{message}}</h1>
</div>

<script>
    let jsonObj = {"username":"zhangsan", "password":"1234"}

    Vue.createApp({
        data(){
            return {
                message:""
            }
        },
        methods: {
            async sendJSON(){
                console.log("sendjson")
                try{
                    const res = await axios.post('/springmvc/send', JSON.stringify(jsonObj), {
                        headers : {
                            "Content-Type" : "application/json"
                        }
                    })
                    this.message = res.data
                }catch(e){
                    console.error(e)
                }
            }
        }
    }).mount("#app")
</script>

</body>
</html>
```



测试结果：  
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1711024282143-bde87ec5-476e-470e-a9fa-94a0f2858938.png#averageHue=%23f1efee&clientId=u2fdcbe87-8e74-4&from=paste&height=111&id=uc1d6aa8a&originHeight=111&originWidth=294&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5364&status=done&style=shadow&taskId=ub786438d-1897-40a6-99f5-b0bb8cb1e92&title=&width=294)

![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1711024299450-33c514e9-a7b1-4010-8d9c-8bd7824a9dd6.png#averageHue=%23f9eeeb&clientId=u2fdcbe87-8e74-4&from=paste&height=143&id=u14a6426a&originHeight=143&originWidth=459&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19019&status=done&style=shadow&taskId=ua3a29b07-da66-41f3-9af1-ea56cfbc128&title=&width=459)



# 四、RequestEntity类（了解）
* R**equestEntity不是一个注解，是一个普通的类。这个类的实例封装了整个请求协议：包括请求行、请求头、请求体所有信息。**
* **出现在控制器方法的参数上**
* **该参数对象是由SpringMVC自动创建好，传递给处理器方法的参数上。 你只需要在处理器方法的参数上加上: (RequestEntity<> requestEntity)即可，SpringMVC自动创建好该对象，传递到处理器方法的参数上。泛型用于指定请求体中所提交的对象。将来获取请求体时可以直接将请求体封装为该泛型对象

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>首页</title>
    <script th:src="@{/static/js/vue3.4.21.js}"></script>
    <script th:src="@{/static/js/axios.min.js}"></script>
</head>
<body>

<div id="app">
    <button @click="sendJSON">通过POST请求发送JSON给服务器</button>
    <h1>{{message}}</h1>
</div>

<script>
    let jsonObj = {"username":"zhangsan", "password":"1234"}

    Vue.createApp({
        data(){
            return {
                message:""
            }
        },
        methods: {
            async sendJSON(){
                console.log("sendjson")
                try{
                    const res = await axios.post('/springmvc/send', JSON.stringify(jsonObj), {
                        headers : {
                            "Content-Type" : "application/json"
                        }
                    })
                    this.message = res.data
                }catch(e){
                    console.error(e)
                }
            }
        }
    }).mount("#app")
</script>

</body>
</html>
```
```java
@RequestMapping("/send")
@ResponseBody
public String send(RequestEntity<User> requestEntity){
    System.out.println("请求方式：" + requestEntity.getMethod());
    System.out.println("请求URL：" + requestEntity.getUrl());
    HttpHeaders headers = requestEntity.getHeaders();
    System.out.println("请求的内容类型：" + headers.getContentType());
    System.out.println("请求头：" + headers);
	//获取请求体
    User user = requestEntity.getBody();
    System.out.println(user);
    System.out.println(user.getUsername());
    System.out.println(user.getPassword());
    return "success";
}
```
测试结果：  
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1711032010156-cb98e4a9-5238-4dd6-ac1a-81dd6198a47d.png#averageHue=%23f9f2f0&clientId=u84c24dc6-b425-4&from=paste&height=253&id=u780ddfcd&originHeight=253&originWidth=615&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36432&status=done&style=shadow&taskId=u179ddeb5-a404-4236-8356-c24a241d08f&title=&width=615)

* **在实际的开发中，如果你需要获取更详细的请求协议中的信息。可以使用`RequestEntity`**


# 五、ResponseEntity类（了解）
* **ResponseEntity不是注解，是一个类。用该类的实例可以封装响应协议，包括：状态行、响应头、响应体。也就是说：如果你想定制属于自己的响应协议，可以使用该类。**
* **注意：如果你要定制属于自己的响应协议，那么处理器方法的返回值类型必须是：ResponseEntity\<User>，泛型为什么是User，因为响应体中的内容是user信息**。

假如我要完成这样一个需求：前端提交一个id，后端根据id进行查询，如果返回null，请在前端显示404错误。如果返回不是null，则输出返回的user。
```java
@Controller
public class UserController {
     
    @GetMapping("/users/{id}")
    public ResponseEntity<User> getUserById(@PathVariable Long id) {
        User user = userService.getUserById(id);
        if (user == null) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
        } else {
            return ResponseEntity.ok(user);
        }
    }
}
```



测试：当用户不存在时  
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1711032765280-343794d6-b262-460b-8c03-e14bd8946850.png#averageHue=%23fefefd&clientId=u84c24dc6-b425-4&from=paste&height=558&id=u565ba7e8&originHeight=558&originWidth=1159&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22933&status=done&style=shadow&taskId=u42f8faab-481d-43af-aa7d-1cc81ae26d8&title=&width=1159)

测试：当用户存在时  
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21376908/1711032830325-866fe36b-cc47-4493-b9bb-8ebd34c7a86c.png#averageHue=%23d6b482&clientId=u84c24dc6-b425-4&from=paste&height=159&id=u262cf82e&originHeight=159&originWidth=515&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14457&status=done&style=shadow&taskId=u41ee96bd-de5c-4a78-bbd2-f90396db356&title=&width=515)
